<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ” æ¸¸æˆå†»ç»“è¯Šæ–­</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; background: #f0f0f0; }
        .container { max-width: 800px; margin: 0 auto; background: white; padding: 20px; border-radius: 10px; }
        .status { margin: 10px 0; padding: 10px; border-radius: 5px; }
        .success { background: #d4edda; color: #155724; }
        .error { background: #f8d7da; color: #721c24; }
        .warning { background: #fff3cd; color: #856404; }
        .info { background: #d1ecf1; color: #0c5460; }
        button { padding: 10px 20px; margin: 10px; border: none; border-radius: 5px; cursor: pointer; }
        .test-btn { background: #007bff; color: white; }
        .test-btn:hover { background: #0056b3; }
        .test-btn:disabled { background: #ccc; cursor: not-allowed; }
        #log { background: #f8f9fa; padding: 15px; border-radius: 5px; margin-top: 20px; max-height: 400px; overflow-y: auto; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ” MAOè½¬ç›˜æ¸¸æˆå†»ç»“è¯Šæ–­</h1>
        
        <div id="status-container">
            <div class="status info">æ­£åœ¨è¿›è¡Œè¯Šæ–­...</div>
        </div>
        
        <div style="margin: 20px 0;">
            <button class="test-btn" onclick="testWalletConnection()">æµ‹è¯•é’±åŒ…è¿æ¥</button>
            <button class="test-btn" onclick="testNetworkConnection()">æµ‹è¯•ç½‘ç»œè¿æ¥</button>
            <button class="test-btn" onclick="testContractConnection()">æµ‹è¯•åˆçº¦è¿æ¥</button>
            <button class="test-btn" onclick="testGameFunction()">æµ‹è¯•æ¸¸æˆåŠŸèƒ½</button>
            <button class="test-btn" onclick="clearLog()">æ¸…é™¤æ—¥å¿—</button>
        </div>
        
        <div id="log"></div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
    <script>
        const CONFIG = {
            ALVEY_NETWORK: {
                chainId: '0xED5',
                chainName: 'AlveyChain Mainnet',
                nativeCurrency: { name: 'Alvey', symbol: 'ALV', decimals: 18 },
                rpcUrls: ['https://elves-core2.alvey.io', 'https://elves-core3.alvey.io', 'https://elves-core1.alvey.io'],
                blockExplorerUrls: ['https://alveyscan.com']
            },
            CONTRACTS: {
                WHEEL_GAME: '0xA9E4FD96B29e4f512a0a75E402C156B04D6E6c35',
                MAO_TOKEN: '0x22f49bcb3dad370a9268ba3fca33cb037ca3d022',
                PI_TOKEN: '0xfd4680e25e05b3435c7f698668d1ce80d2a9f444'
            }
        };

        let gameState = {
            provider: null,
            signer: null,
            account: null,
            contracts: {}
        };

        function log(message, type = 'info') {
            const logDiv = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.className = `status ${type}`;
            logEntry.innerHTML = `[${timestamp}] ${message}`;
            logDiv.appendChild(logEntry);
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(`[${timestamp}] ${message}`);
        }

        function clearLog() {
            document.getElementById('log').innerHTML = '';
        }

        async function testWalletConnection() {
            log('ğŸ” å¼€å§‹æµ‹è¯•é’±åŒ…è¿æ¥...', 'info');
            
            try {
                // æ£€æŸ¥æ˜¯å¦å®‰è£…äº†é’±åŒ…
                if (!window.ethereum) {
                    log('âŒ æœªæ£€æµ‹åˆ°Web3é’±åŒ…', 'error');
                    return false;
                }
                log('âœ… æ£€æµ‹åˆ°Web3é’±åŒ…', 'success');

                // è¯·æ±‚è´¦æˆ·è®¿é—®
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                if (accounts.length === 0) {
                    log('âŒ æœªé€‰æ‹©è´¦æˆ·', 'error');
                    return false;
                }
                
                gameState.account = accounts[0];
                log(`âœ… è´¦æˆ·è¿æ¥æˆåŠŸ: ${gameState.account}`, 'success');

                // æ£€æŸ¥ç½‘ç»œ
                const chainId = await window.ethereum.request({ method: 'eth_chainId' });
                log(`ğŸ“¡ å½“å‰ç½‘ç»œ Chain ID: ${chainId}`, 'info');
                
                if (chainId !== CONFIG.ALVEY_NETWORK.chainId) {
                    log('âš ï¸  ç½‘ç»œä¸åŒ¹é…ï¼Œéœ€è¦åˆ‡æ¢åˆ° AlveyChain', 'warning');
                    try {
                        await window.ethereum.request({
                            method: 'wallet_switchEthereumChain',
                            params: [{ chainId: CONFIG.ALVEY_NETWORK.chainId }]
                        });
                        log('âœ… ç½‘ç»œåˆ‡æ¢æˆåŠŸ', 'success');
                    } catch (switchError) {
                        if (switchError.code === 4902) {
                            log('ğŸ”§ å°è¯•æ·»åŠ  AlveyChain ç½‘ç»œ...', 'info');
                            await window.ethereum.request({
                                method: 'wallet_addEthereumChain',
                                params: [CONFIG.ALVEY_NETWORK]
                            });
                            log('âœ… AlveyChain ç½‘ç»œæ·»åŠ æˆåŠŸ', 'success');
                        } else {
                            throw switchError;
                        }
                    }
                } else {
                    log('âœ… ç½‘ç»œåŒ¹é…æ­£ç¡®', 'success');
                }

                // åˆ›å»º provider å’Œ signer
                gameState.provider = new ethers.providers.Web3Provider(window.ethereum);
                gameState.signer = gameState.provider.getSigner();
                log('âœ… Provider å’Œ Signer åˆ›å»ºæˆåŠŸ', 'success');

                return true;
            } catch (error) {
                log(`âŒ é’±åŒ…è¿æ¥å¤±è´¥: ${error.message}`, 'error');
                return false;
            }
        }

        async function testNetworkConnection() {
            log('ğŸ” å¼€å§‹æµ‹è¯•ç½‘ç»œè¿æ¥...', 'info');
            
            const rpcUrls = CONFIG.ALVEY_NETWORK.rpcUrls;
            
            for (const rpcUrl of rpcUrls) {
                try {
                    log(`ğŸ“¡ æµ‹è¯• RPC: ${rpcUrl}`, 'info');
                    const provider = new ethers.providers.JsonRpcProvider(rpcUrl);
                    const network = await provider.getNetwork();
                    log(`âœ… RPC è¿æ¥æˆåŠŸ: ${rpcUrl}, Chain ID: ${network.chainId}`, 'success');
                    return true;
                } catch (error) {
                    log(`âŒ RPC è¿æ¥å¤±è´¥: ${rpcUrl} - ${error.message}`, 'error');
                }
            }
            
            log('âŒ æ‰€æœ‰ RPC è¿æ¥éƒ½å¤±è´¥', 'error');
            return false;
        }

        async function testContractConnection() {
            log('ğŸ” å¼€å§‹æµ‹è¯•åˆçº¦è¿æ¥...', 'info');
            
            if (!gameState.provider) {
                log('âŒ è¯·å…ˆæµ‹è¯•é’±åŒ…è¿æ¥', 'error');
                return false;
            }

            try {
                const wheelGameABI = [
                    "function playMAOGame() external",
                    "function playPIGame() external",
                    "event GamePlayed(address indexed player, uint8 tokenType, uint256 betAmount, uint256 rewardAmount, uint8 rewardLevel, uint256 randomSeed)"
                ];
                
                const erc20ABI = [
                    "function balanceOf(address owner) view returns (uint256)",
                    "function approve(address spender, uint256 amount) returns (bool)",
                    "function allowance(address owner, address spender) view returns (uint256)"
                ];

                // æµ‹è¯•åˆçº¦è¿æ¥
                const wheelGame = new ethers.Contract(CONFIG.CONTRACTS.WHEEL_GAME, wheelGameABI, gameState.signer);
                const maoToken = new ethers.Contract(CONFIG.CONTRACTS.MAO_TOKEN, erc20ABI, gameState.signer);
                const piToken = new ethers.Contract(CONFIG.CONTRACTS.PI_TOKEN, erc20ABI, gameState.signer);

                log(`ğŸ“ æ¸¸æˆåˆçº¦: ${CONFIG.CONTRACTS.WHEEL_GAME}`, 'info');
                log(`ğŸ“ MAO ä»£å¸: ${CONFIG.CONTRACTS.MAO_TOKEN}`, 'info');
                log(`ğŸ“ PI ä»£å¸: ${CONFIG.CONTRACTS.PI_TOKEN}`, 'info');

                // æµ‹è¯•ä½™é¢æŸ¥è¯¢
                const maoBalance = await maoToken.balanceOf(gameState.account);
                const piBalance = await piToken.balanceOf(gameState.account);
                
                log(`ğŸ’° MAO ä½™é¢: ${ethers.utils.formatEther(maoBalance)}`, 'success');
                log(`ğŸ’° PI ä½™é¢: ${ethers.utils.formatEther(piBalance)}`, 'success');

                gameState.contracts = { wheelGame, maoToken, piToken };
                log('âœ… åˆçº¦è¿æ¥æˆåŠŸ', 'success');
                return true;
            } catch (error) {
                log(`âŒ åˆçº¦è¿æ¥å¤±è´¥: ${error.message}`, 'error');
                return false;
            }
        }

        async function testGameFunction() {
            log('ğŸ” å¼€å§‹æµ‹è¯•æ¸¸æˆåŠŸèƒ½...', 'info');
            
            if (!gameState.contracts.maoToken) {
                log('âŒ è¯·å…ˆæµ‹è¯•åˆçº¦è¿æ¥', 'error');
                return false;
            }

            try {
                // æ£€æŸ¥ MAO æˆæƒ
                const maoAllowance = await gameState.contracts.maoToken.allowance(
                    gameState.account, 
                    CONFIG.CONTRACTS.WHEEL_GAME
                );
                log(`ğŸ” MAO æˆæƒé¢åº¦: ${ethers.utils.formatEther(maoAllowance)}`, 'info');

                // æ£€æŸ¥ PI æˆæƒ
                const piAllowance = await gameState.contracts.piToken.allowance(
                    gameState.account, 
                    CONFIG.CONTRACTS.WHEEL_GAME
                );
                log(`ğŸ” PI æˆæƒé¢åº¦: ${ethers.utils.formatEther(piAllowance)}`, 'info');

                // æ£€æŸ¥ä½™é¢æ˜¯å¦è¶³å¤Ÿ
                const maoBalance = await gameState.contracts.maoToken.balanceOf(gameState.account);
                const piBalance = await gameState.contracts.piToken.balanceOf(gameState.account);
                
                const maoBalanceNum = parseFloat(ethers.utils.formatEther(maoBalance));
                const piBalanceNum = parseFloat(ethers.utils.formatEther(piBalance));
                
                if (maoBalanceNum >= 100) {
                    log('âœ… MAO ä½™é¢è¶³å¤Ÿæ¸¸æˆ (éœ€è¦ 100 MAO)', 'success');
                } else {
                    log('âŒ MAO ä½™é¢ä¸è¶³ (éœ€è¦ 100 MAO)', 'error');
                }
                
                if (piBalanceNum >= 1000) {
                    log('âœ… PI ä½™é¢è¶³å¤Ÿæ¸¸æˆ (éœ€è¦ 1000 PI)', 'success');
                } else {
                    log('âŒ PI ä½™é¢ä¸è¶³ (éœ€è¦ 1000 PI)', 'error');
                }

                // æ£€æŸ¥æˆæƒæ˜¯å¦è¶³å¤Ÿ
                const maoAllowanceNum = parseFloat(ethers.utils.formatEther(maoAllowance));
                const piAllowanceNum = parseFloat(ethers.utils.formatEther(piAllowance));
                
                if (maoAllowanceNum >= 100) {
                    log('âœ… MAO æˆæƒè¶³å¤Ÿ', 'success');
                } else {
                    log('âš ï¸  MAO éœ€è¦æˆæƒæ‰èƒ½æ¸¸æˆ', 'warning');
                }
                
                if (piAllowanceNum >= 1000) {
                    log('âœ… PI æˆæƒè¶³å¤Ÿ', 'success');
                } else {
                    log('âš ï¸  PI éœ€è¦æˆæƒæ‰èƒ½æ¸¸æˆ', 'warning');
                }

                log('âœ… æ¸¸æˆåŠŸèƒ½æµ‹è¯•å®Œæˆ', 'success');
                return true;
            } catch (error) {
                log(`âŒ æ¸¸æˆåŠŸèƒ½æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
                return false;
            }
        }

        // é¡µé¢åŠ è½½æ—¶è‡ªåŠ¨å¼€å§‹è¯Šæ–­
        window.addEventListener('load', async () => {
            log('ğŸš€ å¼€å§‹è‡ªåŠ¨è¯Šæ–­...', 'info');
            
            // ç­‰å¾…ä¸€ç§’è®©é¡µé¢å®Œå…¨åŠ è½½
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            const walletOk = await testWalletConnection();
            if (walletOk) {
                const networkOk = await testNetworkConnection();
                if (networkOk) {
                    const contractOk = await testContractConnection();
                    if (contractOk) {
                        await testGameFunction();
                    }
                }
            }
            
            log('ğŸ è‡ªåŠ¨è¯Šæ–­å®Œæˆ', 'info');
        });
    </script>
</body>
</html> 