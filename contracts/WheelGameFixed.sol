// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

/**
 * @title WheelGameFixed
 * @dev ‰øÆÊ≠£ÁâàËΩ¨ÁõòÊ∏∏ÊàèÂêàÁ∫¶ - ÁúüÊ≠£ÁöÑ50%‰∏≠Â•ñÁéá
 * 
 * üéØ ‰øÆÊ≠£ÂÜÖÂÆπ:
 * - Ê¶ÇÁéáÈÖçÁΩÆ‰øÆÊ≠£‰∏∫ÁúüÊ≠£ÁöÑ50%‰∏≠Â•ñÁéá
 * - ÊîπËøõÈöèÊú∫Êï∞ÁîüÊàêÊú∫Âà∂
 * - Ê∑ªÂä†ËøûË¥•‰øùÊä§Êú∫Âà∂
 * - Â¢ûÂº∫ÈÄèÊòéÂ∫¶ÂíåÂèØÈ™åËØÅÊÄß
 */
contract WheelGameFixed is ReentrancyGuard, Ownable {
    IERC20 public maoToken;
    IERC20 public piToken;
    
    address public marketingWallet;
    address public prizePool;
    address public constant BURN_ADDRESS = 0x000000000000000000000000000000000000dEaD;
    
    // Ê∏∏ÊàèÂèÇÊï∞
    uint256 public constant MAO_BET_AMOUNT = 100 * 10**18; // 100 MAO
    uint256 public constant PI_BET_AMOUNT = 1000 * 10**18; // 1000 PI
    
    // üéØ ‰øÆÊ≠£ÂêéÁöÑMAOÂ•ñÂä±ÈÖçÁΩÆ - 50%‰∏≠Â•ñÁéá
    uint256[6] public maoRewards = [
        0,            // Ë∞¢Ë∞¢ÊÉ†È°æ 50%
        105 * 10**18, // Â∞èÂ•ñ 105 MAO (22%)
        125 * 10**18, // ‰∏≠Â•ñ 125 MAO (20%)
        200 * 10**18, // Â§ßÂ•ñ 200 MAO (7%)
        600 * 10**18, // Ë∂ÖÁ∫ßÂ§ßÂ•ñ 600 MAO (0.8%)
        1000 * 10**18 // ÁªàÊûÅÂ§ßÂ•ñ 1000 MAO (0.2%)
    ];
    
    // üéØ ‰øÆÊ≠£ÂêéÁöÑPIÂ•ñÂä±ÈÖçÁΩÆ - 50%‰∏≠Â•ñÁéá
    uint256[6] public piRewards = [
        0,               // Ë∞¢Ë∞¢ÊÉ†È°æ 50%
        1050 * 10**18,   // Â∞èÂ•ñ 1,050 PI (22%)
        1250 * 10**18,   // ‰∏≠Â•ñ 1,250 PI (20%)
        2000 * 10**18,   // Â§ßÂ•ñ 2,000 PI (7%)
        6000 * 10**18,   // Ë∂ÖÁ∫ßÂ§ßÂ•ñ 6,000 PI (0.8%)
        10000 * 10**18   // ÁªàÊûÅÂ§ßÂ•ñ 10,000 PI (0.2%)
    ];
    
    // üéØ ‰øÆÊ≠£ÂêéÁöÑÊ¶ÇÁéáÂå∫Èó¥ - ÁúüÊ≠£ÁöÑ50%‰∏≠Â•ñÁéá
    uint256[6] public probabilityRanges = [
        5000,  // Ë∞¢Ë∞¢ÊÉ†È°æ 50.0% (0-4999)
        7200,  // Â∞èÂ•ñ 22.0% (5000-7199)
        9200,  // ‰∏≠Â•ñ 20.0% (7200-9199)
        9900,  // Â§ßÂ•ñ 7.0% (9200-9899)
        9980,  // Ë∂ÖÁ∫ßÂ§ßÂ•ñ 0.8% (9900-9979)
        10000  // ÁªàÊûÅÂ§ßÂ•ñ 0.2% (9980-9999)
    ];
    
    // üí∞ ËµÑÈáëÂàÜÈÖçÊØî‰æã
    uint256 public constant PRIZE_POOL_PERCENT = 70;  // 70%Âà∞Â•ñÈáëÊ±†
    uint256 public constant BURN_PERCENT = 15;        // 15%ÈîÄÊØÅ
    uint256 public constant MARKETING_PERCENT = 15;   // 15%Ëê•ÈîÄ
    
    // üîí ËøûË¥•‰øùÊä§Êú∫Âà∂
    mapping(address => uint256) public consecutiveLosses;
    uint256 public constant MAX_CONSECUTIVE_LOSSES = 5; // ËøûÁª≠5Ê¨°Â§±Ë¥•ÂêéËß¶Âèë‰øùÊä§
    
    // Ê∏∏ÊàèËÆ∞ÂΩï
    struct GameResult {
        address player;
        uint8 tokenType; // 0=MAO, 1=PI
        uint256 betAmount;
        uint256 rewardAmount;
        uint8 rewardLevel;
        uint256 timestamp;
        uint256 randomSeed;
        bool wasProtected; // ÊòØÂê¶Ëß¶Âèë‰∫ÜËøûË¥•‰øùÊä§
    }
    
    mapping(address => GameResult[]) public playerHistory;
    GameResult[] public allGames;
    
    // ÁªüËÆ°Êï∞ÊçÆ
    struct GameStats {
        uint256 totalGames;
        uint256 totalWins;
        uint256 totalBets;
        uint256 totalRewards;
        uint256 protectedGames; // ËøûË¥•‰øùÊä§Ëß¶ÂèëÊ¨°Êï∞
    }
    
    mapping(uint8 => GameStats) public tokenStats; // 0=MAO, 1=PI
    
    // ‰∫ã‰ª∂
    event GamePlayed(
        address indexed player,
        uint8 tokenType,
        uint256 betAmount,
        uint256 rewardAmount,
        uint8 rewardLevel,
        uint256 randomSeed,
        bool wasProtected
    );
    
    event ConsecutiveLossProtectionTriggered(address indexed player, uint256 lossCount);
    event ProbabilityConfigUpdated(string reason);
    event TokensBurned(address indexed token, uint256 amount);
    
    constructor(
        address _maoToken,
        address _piToken,
        address _marketingWallet,
        address _prizePool
    ) {
        maoToken = IERC20(_maoToken);
        piToken = IERC20(_piToken);
        marketingWallet = _marketingWallet;
        prizePool = _prizePool;
        
        emit ProbabilityConfigUpdated("Contract deployed with fixed 50% win rate");
    }
    
    // üîß ÊîπËøõÁöÑÈöèÊú∫Êï∞ÁîüÊàêÂáΩÊï∞
    function generateRandomNumber(address player, uint256 nonce) private view returns (uint256) {
        return uint256(keccak256(abi.encodePacked(
            block.timestamp,
            block.difficulty,
            player,
            nonce,
            blockhash(block.number - 1),
            gasleft(),          // Ââ©‰ΩôgasÂ¢ûÂä†ÈöèÊú∫ÊÄß
            tx.gasprice,        // gas‰ª∑Ê†ºÂ¢ûÂä†ÈöèÊú∫ÊÄß
            block.coinbase      // ÁüøÂ∑•Âú∞ÂùÄÂ¢ûÂä†ÈöèÊú∫ÊÄß
        ))) % 10000;
    }
    
    // Ê†πÊçÆÈöèÊú∫Êï∞Á°ÆÂÆöÂ•ñÂä±Á≠âÁ∫ßÔºàÂ∏¶ËøûË¥•‰øùÊä§Ôºâ
    function getRewardLevel(uint256 randomNum, address player, bool applyProtection) private returns (uint8) {
        // ËøûË¥•‰øùÊä§Êú∫Âà∂
        if (applyProtection && consecutiveLosses[player] >= MAX_CONSECUTIVE_LOSSES) {
            consecutiveLosses[player] = 0;
            emit ConsecutiveLossProtectionTriggered(player, MAX_CONSECUTIVE_LOSSES);
            return 1; // Âº∫Âà∂Áªô‰∫àÂ∞èÂ•ñ
        }
        
        // Ê≠£Â∏∏Ê¶ÇÁéáÂà§Êñ≠
        for (uint8 i = 0; i < 6; i++) {
            if (randomNum < probabilityRanges[i]) {
                // Êõ¥Êñ∞ËøûË¥•ËÆ°Êï∞
                if (i == 0) {
                    consecutiveLosses[player]++;
                } else {
                    consecutiveLosses[player] = 0;
                }
                return i;
            }
        }
        
        // ÈªòËÆ§ËøîÂõûË∞¢Ë∞¢ÊÉ†È°æ
        consecutiveLosses[player]++;
        return 0;
    }
    
    // MAOÊ∏∏Êàè - ‰øÆÊ≠£Áâà
    function playMAOGame() external nonReentrant {
        require(maoToken.balanceOf(msg.sender) >= MAO_BET_AMOUNT, "Insufficient MAO balance");
        require(maoToken.allowance(msg.sender, address(this)) >= MAO_BET_AMOUNT, "Insufficient MAO allowance");
        
        // ËΩ¨ÂÖ•ÊäïÊ≥®ÈáëÈ¢ù
        require(maoToken.transferFrom(msg.sender, address(this), MAO_BET_AMOUNT), "MAO transfer failed");
        
        // ËµÑÈáëÂàÜÈÖç
        uint256 toPrizePool = (MAO_BET_AMOUNT * PRIZE_POOL_PERCENT) / 100;   // 70 MAO
        uint256 toBurn = (MAO_BET_AMOUNT * BURN_PERCENT) / 100;              // 15 MAO
        uint256 toMarketing = (MAO_BET_AMOUNT * MARKETING_PERCENT) / 100;    // 15 MAO
        
        require(maoToken.transfer(prizePool, toPrizePool), "Prize pool transfer failed");
        require(maoToken.transfer(BURN_ADDRESS, toBurn), "Burn transfer failed");
        require(maoToken.transfer(marketingWallet, toMarketing), "Marketing transfer failed");
        
        emit TokensBurned(address(maoToken), toBurn);
        
        // ÁîüÊàêÈöèÊú∫Êï∞Âπ∂Á°ÆÂÆöÂ•ñÂä±ÔºàÂ∏¶ËøûË¥•‰øùÊä§Ôºâ
        uint256 randomSeed = generateRandomNumber(msg.sender, allGames.length);
        uint8 rewardLevel = getRewardLevel(randomSeed, msg.sender, true);
        uint256 rewardAmount = maoRewards[rewardLevel];
        bool wasProtected = (consecutiveLosses[msg.sender] == 0 && rewardLevel > 0 && randomSeed < probabilityRanges[0]);
        
        // ‰ªéÂ•ñÈáëÊ±†ÂèëÊîæÂ•ñÂä±
        if (rewardAmount > 0) {
            require(maoToken.allowance(prizePool, address(this)) >= rewardAmount, "Insufficient prize pool allowance");
            require(maoToken.transferFrom(prizePool, msg.sender, rewardAmount), "Reward transfer failed");
        }
        
        // ËÆ∞ÂΩïÊ∏∏ÊàèÁªìÊûú
        GameResult memory gameResult = GameResult({
            player: msg.sender,
            tokenType: 0, // MAO
            betAmount: MAO_BET_AMOUNT,
            rewardAmount: rewardAmount,
            rewardLevel: rewardLevel,
            timestamp: block.timestamp,
            randomSeed: randomSeed,
            wasProtected: wasProtected
        });
        
        playerHistory[msg.sender].push(gameResult);
        allGames.push(gameResult);
        
        // Êõ¥Êñ∞ÁªüËÆ°Êï∞ÊçÆ
        tokenStats[0].totalGames++;
        tokenStats[0].totalBets += MAO_BET_AMOUNT;
        if (rewardAmount > 0) {
            tokenStats[0].totalWins++;
            tokenStats[0].totalRewards += rewardAmount;
        }
        if (wasProtected) {
            tokenStats[0].protectedGames++;
        }
        
        emit GamePlayed(msg.sender, 0, MAO_BET_AMOUNT, rewardAmount, rewardLevel, randomSeed, wasProtected);
    }
    
    // PIÊ∏∏Êàè - ‰øÆÊ≠£Áâà
    function playPIGame() external nonReentrant {
        require(piToken.balanceOf(msg.sender) >= PI_BET_AMOUNT, "Insufficient PI balance");
        require(piToken.allowance(msg.sender, address(this)) >= PI_BET_AMOUNT, "Insufficient PI allowance");
        
        // ËΩ¨ÂÖ•ÊäïÊ≥®ÈáëÈ¢ù
        require(piToken.transferFrom(msg.sender, address(this), PI_BET_AMOUNT), "PI transfer failed");
        
        // ËµÑÈáëÂàÜÈÖç
        uint256 toPrizePool = (PI_BET_AMOUNT * PRIZE_POOL_PERCENT) / 100;   // 700 PI
        uint256 toBurn = (PI_BET_AMOUNT * BURN_PERCENT) / 100;              // 150 PI
        uint256 toMarketing = (PI_BET_AMOUNT * MARKETING_PERCENT) / 100;    // 150 PI
        
        require(piToken.transfer(prizePool, toPrizePool), "Prize pool transfer failed");
        require(piToken.transfer(BURN_ADDRESS, toBurn), "Burn transfer failed");
        require(piToken.transfer(marketingWallet, toMarketing), "Marketing transfer failed");
        
        emit TokensBurned(address(piToken), toBurn);
        
        // ÁîüÊàêÈöèÊú∫Êï∞Âπ∂Á°ÆÂÆöÂ•ñÂä±ÔºàÂ∏¶ËøûË¥•‰øùÊä§Ôºâ
        uint256 randomSeed = generateRandomNumber(msg.sender, allGames.length);
        uint8 rewardLevel = getRewardLevel(randomSeed, msg.sender, true);
        uint256 rewardAmount = piRewards[rewardLevel];
        bool wasProtected = (consecutiveLosses[msg.sender] == 0 && rewardLevel > 0 && randomSeed < probabilityRanges[0]);
        
        // ‰ªéÂ•ñÈáëÊ±†ÂèëÊîæÂ•ñÂä±
        if (rewardAmount > 0) {
            require(piToken.allowance(prizePool, address(this)) >= rewardAmount, "Insufficient prize pool allowance");
            require(piToken.transferFrom(prizePool, msg.sender, rewardAmount), "Reward transfer failed");
        }
        
        // ËÆ∞ÂΩïÊ∏∏ÊàèÁªìÊûú
        GameResult memory gameResult = GameResult({
            player: msg.sender,
            tokenType: 1, // PI
            betAmount: PI_BET_AMOUNT,
            rewardAmount: rewardAmount,
            rewardLevel: rewardLevel,
            timestamp: block.timestamp,
            randomSeed: randomSeed,
            wasProtected: wasProtected
        });
        
        playerHistory[msg.sender].push(gameResult);
        allGames.push(gameResult);
        
        // Êõ¥Êñ∞ÁªüËÆ°Êï∞ÊçÆ
        tokenStats[1].totalGames++;
        tokenStats[1].totalBets += PI_BET_AMOUNT;
        if (rewardAmount > 0) {
            tokenStats[1].totalWins++;
            tokenStats[1].totalRewards += rewardAmount;
        }
        if (wasProtected) {
            tokenStats[1].protectedGames++;
        }
        
        emit GamePlayed(msg.sender, 1, PI_BET_AMOUNT, rewardAmount, rewardLevel, randomSeed, wasProtected);
    }
    
    // üîç ÈÄèÊòéÂ∫¶ÂäüËÉΩÔºöËé∑ÂèñÁé©ÂÆ∂Ê∏∏ÊàèÂéÜÂè≤
    function getPlayerHistory(address player) external view returns (GameResult[] memory) {
        return playerHistory[player];
    }
    
    // üîç ÈÄèÊòéÂ∫¶ÂäüËÉΩÔºöËé∑ÂèñÊ¶ÇÁéáÈÖçÁΩÆ
    function getProbabilityRanges() external view returns (uint256[6] memory) {
        return probabilityRanges;
    }
    
    // üîç ÈÄèÊòéÂ∫¶ÂäüËÉΩÔºöËé∑ÂèñÂ•ñÂä±ÈÖçÁΩÆ
    function getRewardConfig(uint8 tokenType) external view returns (uint256[6] memory) {
        return tokenType == 0 ? maoRewards : piRewards;
    }
    
    // üîç ÈÄèÊòéÂ∫¶ÂäüËÉΩÔºöËÆ°ÁÆóÂÆûÈôÖ‰∏≠Â•ñÁéá
    function getActualWinRate(uint8 tokenType) external view returns (uint256) {
        GameStats memory stats = tokenStats[tokenType];
        if (stats.totalGames == 0) return 0;
        return (stats.totalWins * 10000) / stats.totalGames; // ËøîÂõûÂü∫ÁÇπ(‰∏áÂàÜ‰πã‰∏Ä)
    }
    
    // üîç ÈÄèÊòéÂ∫¶ÂäüËÉΩÔºöËé∑ÂèñÁé©ÂÆ∂ËøûË¥•Ê¨°Êï∞
    function getPlayerConsecutiveLosses(address player) external view returns (uint256) {
        return consecutiveLosses[player];
    }
    
    // üîç ÈÄèÊòéÂ∫¶ÂäüËÉΩÔºöËé∑ÂèñÊ∏∏ÊàèÁªüËÆ°
    function getGameStats(uint8 tokenType) external view returns (GameStats memory) {
        return tokenStats[tokenType];
    }
    
    // üìä ÁÆ°ÁêÜÂäüËÉΩÔºöÊõ¥Êñ∞Ëê•ÈîÄÈí±ÂåÖ
    function updateMarketingWallet(address newMarketingWallet) external onlyOwner {
        require(newMarketingWallet != address(0), "Invalid marketing wallet address");
        marketingWallet = newMarketingWallet;
    }
    
    // üìä ÁÆ°ÁêÜÂäüËÉΩÔºöÊõ¥Êñ∞Â•ñÈáëÊ±†Âú∞ÂùÄ
    function updatePrizePool(address newPrizePool) external onlyOwner {
        require(newPrizePool != address(0), "Invalid prize pool address");
        prizePool = newPrizePool;
    }
    
    // üö® Á¥ßÊÄ•ÂäüËÉΩÔºöÊèêÂèñÂêàÁ∫¶‰ª£Â∏ÅÔºà‰ªÖÈôêÊâÄÊúâËÄÖÔºâ
    function emergencyWithdraw(address token, uint256 amount) external onlyOwner {
        require(IERC20(token).transfer(owner(), amount), "Emergency withdraw failed");
    }
    
    // üí∞ Â∑•ÂÖ∑ÂäüËÉΩÔºöËé∑ÂèñÂêàÁ∫¶‰ª£Â∏Å‰ΩôÈ¢ù
    function getContractBalance(address token) external view returns (uint256) {
        return IERC20(token).balanceOf(address(this));
    }
    
    // üí∞ Â∑•ÂÖ∑ÂäüËÉΩÔºöËé∑ÂèñÂ•ñÈáëÊ±†‰ª£Â∏Å‰ΩôÈ¢ù
    function getPrizePoolBalance(address token) external view returns (uint256) {
        return IERC20(token).balanceOf(prizePool);
    }
} 