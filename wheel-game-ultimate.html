<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ° MAO Real Blockchain Wheel - v8.1 FIXED</title>
    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { background: linear-gradient(135deg, #667eea, #764ba2); min-height: 100vh; font-family: Inter, sans-serif; }
        .glass { background: rgba(255,255,255,0.15); backdrop-filter: blur(20px); border: 1px solid rgba(255,255,255,0.3); }
        .wheel { width: 300px; height: 300px; border-radius: 50%; background: conic-gradient(from 0deg, #ef4444 0deg 180deg, #10b981 180deg 360deg); transition: transform 4s ease; position: relative; }
        .spinning { animation: spin 4s ease; }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(1800deg); } }
        .token-btn { padding: 12px 24px; border-radius: 12px; cursor: pointer; transition: all 0.3s; }
        .token-btn.active { background: linear-gradient(135deg, #f59e0b, #fbbf24); color: black; }
        .game-btn { background: linear-gradient(135deg, #10b981, #059669); color: white; padding: 16px 32px; border-radius: 16px; font-weight: bold; cursor: pointer; transition: all 0.3s; }
        .loading { width: 20px; height: 20px; border: 2px solid #fff; border-top: 2px solid #f59e0b; border-radius: 50%; animation: rotate 1s linear infinite; }
        @keyframes rotate { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
    </style>
</head>
<body class="text-white">
    <div class="container mx-auto p-8">
        <h1 class="text-4xl font-bold text-center mb-8">ğŸ° MAO Real Blockchain Wheel</h1>
        
        <!-- Wallet Section -->
        <div class="glass rounded-2xl p-6 mb-8">
            <div id="walletDisconnected">
                <button id="connectBtn" class="game-btn mx-auto block">è¿æ¥ MetaMask</button>
            </div>
            <div id="walletConnected" class="hidden">
                <div class="text-center mb-4">
                    <span class="text-green-400">å·²è¿æ¥:</span>
                    <span id="walletAddress" class="font-mono"></span>
                </div>
                <div class="grid grid-cols-2 gap-4 mb-6">
                    <div class="glass rounded-xl p-4 text-center">
                        <div class="text-2xl mb-2">ğŸ±</div>
                        <div class="text-yellow-400 text-2xl font-bold" id="maoBalance">0</div>
                        <div class="text-sm">MAO</div>
                    </div>
                    <div class="glass rounded-xl p-4 text-center">
                        <div class="text-2xl mb-2">ğŸ¥§</div>
                        <div class="text-green-400 text-2xl font-bold" id="piBalance">0</div>
                        <div class="text-sm">PI</div>
                    </div>
                </div>
                
                <!-- Token Selection -->
                <div class="flex justify-center mb-6">
                    <div class="glass rounded-xl p-2 flex gap-2">
                        <button id="selectMao" class="token-btn active">ğŸ± MAO (100)</button>
                        <button id="selectPi" class="token-btn">ğŸ¥§ PI (1000)</button>
                    </div>
                </div>
                
                <!-- Wheel -->
                <div class="flex justify-center mb-6">
                    <div class="relative">
                        <div class="wheel" id="wheel">
                            <div class="absolute inset-0 flex items-center justify-center">
                                <div class="w-16 h-16 bg-white rounded-full flex items-center justify-center">
                                    <span class="text-2xl">ğŸ¯</span>
                                </div>
                            </div>
                        </div>
                        <div class="absolute top-0 left-1/2 transform -translate-x-1/2 -translate-y-2">
                            <div class="w-0 h-0 border-l-4 border-r-4 border-b-8 border-transparent border-b-yellow-400"></div>
                        </div>
                    </div>
                </div>
                
                <!-- Game Button -->
                <div class="text-center">
                    <button id="spinBtn" class="game-btn">ğŸ² çœŸå®åŒºå—é“¾è½¬ç›˜</button>
                    <div id="gameStatus" class="mt-4 text-sm">ğŸ”— åŒºå—é“¾æ¸¸æˆå°±ç»ª - çœŸå®ä»£å¸æŠ•å…¥</div>
                </div>
            </div>
        </div>
        
        <!-- Stats -->
        <div class="glass rounded-2xl p-6">
            <h3 class="text-xl font-semibold mb-4">ğŸ“Š åŒºå—é“¾ç»Ÿè®¡</h3>
            <div class="grid grid-cols-4 gap-4">
                <div class="text-center">
                    <div class="text-2xl font-bold text-blue-400" id="totalGames">0</div>
                    <div class="text-sm">æ€»å±€æ•°</div>
                </div>
                <div class="text-center">
                    <div class="text-2xl font-bold text-green-400" id="winCount">0</div>
                    <div class="text-sm">èƒœåˆ©æ•°</div>
                </div>
                <div class="text-center">
                    <div class="text-2xl font-bold text-yellow-400" id="winRate">0%</div>
                    <div class="text-sm">èƒœç‡</div>
                </div>
                <div class="text-center">
                    <div class="text-2xl font-bold text-purple-400" id="totalReward">0</div>
                    <div class="text-sm">æ€»å¥–åŠ±</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Result Modal -->
    <div id="resultModal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center hidden">
        <div class="glass rounded-2xl p-8 max-w-md text-center">
            <div id="resultIcon" class="text-6xl mb-4"></div>
            <h3 id="resultTitle" class="text-2xl font-bold mb-2"></h3>
            <p id="resultMessage" class="mb-4"></p>
            <div id="resultReward" class="text-3xl font-bold text-yellow-400 mb-6"></div>
            <div id="txHash" class="text-xs text-blue-300 mb-4 font-mono break-all"></div>
            <button id="closeModal" class="game-btn">ç»§ç»­æ¸¸æˆ</button>
        </div>
    </div>

    <script>
        // ğŸ”— ä¿®å¤ç‰ˆçœŸå®åŒºå—é“¾æ¸¸æˆå¼•æ“
        class FixedBlockchainGameEngine {
            constructor() {
                this.state = {
                    wallet: { connected: false, address: null, provider: null, signer: null },
                    selectedToken: 'MAO',
                    isSpinning: false,
                    stats: { totalGames: 0, winCount: 0, totalReward: 0 },
                    contracts: { mao: null, pi: null, wheelGame: null }
                };
                
                // ğŸ”— çœŸå®åˆçº¦åœ°å€
                this.addresses = {
                    MAO_TOKEN: "0x22f49bcb3dad370a9268ba3fca33cb037ca3d022",
                    PI_TOKEN: "0xfd4680e25e05b3435c7f698668d1ce80d2a9f444",
                    WHEEL_GAME: "0x621DF9e0DE6b4e7EDC5Dc22Cd7c0F883c3F56966"
                };

                this.tokenABI = [
                    "function balanceOf(address owner) external view returns (uint256)",
                    "function approve(address spender, uint256 amount) external returns (bool)",
                    "function allowance(address owner, address spender) external view returns (uint256)"
                ];

                // ğŸ”§ ä¿®å¤çš„æ¸¸æˆåˆçº¦ABI - å…¼å®¹AlveyChain
                this.wheelGameABI = [
                    "function playMAOGame() external",
                    "function playPIGame() external",
                    "function getPlayerHistory(address player) external view returns (tuple(address player, uint8 tokenType, uint256 betAmount, uint256 rewardAmount, uint8 rewardLevel, uint256 timestamp, uint256 randomSeed, bool wasProtected)[])",
                    "function getGameStats(uint8 tokenType) external view returns (tuple(uint256 totalGames, uint256 totalWins, uint256 totalBets, uint256 totalRewards, uint256 protectedGames))",
                    "function getPlayerConsecutiveLosses(address player) external view returns (uint256)",
                    "event GamePlayed(address indexed player, uint8 tokenType, uint256 betAmount, uint256 rewardAmount, uint8 rewardLevel, uint256 randomSeed, bool wasProtected)"
                ];
            }

            formatAddress(addr) {
                return addr ? `${addr.slice(0, 6)}...${addr.slice(-4)}` : '';
            }

            formatNumber(num) {
                return Math.floor(Number(num)).toLocaleString();
            }

            setGameStatus(message, type = 'info') {
                const statusEl = document.getElementById('gameStatus');
                if (statusEl) {
                    const icons = { info: 'ğŸ”—', success: 'âœ…', warning: 'âš ï¸', error: 'âŒ' };
                    statusEl.innerHTML = `${icons[type]} ${message}`;
                }
            }

            updateTokenSelection() {
                const maoBtn = document.getElementById('selectMao');
                const piBtn = document.getElementById('selectPi');
                
                if (this.state.selectedToken === 'MAO') {
                    maoBtn?.classList.add('active');
                    piBtn?.classList.remove('active');
                } else {
                    maoBtn?.classList.remove('active');
                    piBtn?.classList.add('active');
                }
            }

            updateGameUI(isPlaying) {
                const spinBtn = document.getElementById('spinBtn');
                const tokenBtns = document.querySelectorAll('.token-btn');
                
                if (isPlaying) {
                    spinBtn.disabled = true;
                    spinBtn.innerHTML = '<div class="loading mx-auto"></div>';
                    tokenBtns.forEach(btn => btn.disabled = true);
                } else {
                    spinBtn.disabled = false;
                    spinBtn.innerHTML = 'ğŸ² çœŸå®åŒºå—é“¾è½¬ç›˜';
                    tokenBtns.forEach(btn => btn.disabled = false);
                }
            }

            updateStats() {
                const { stats } = this.state;
                const elements = ['totalGames', 'winCount', 'totalReward', 'winRate'].map(id => 
                    ({ id, el: document.getElementById(id) })
                );
                
                elements[0].el && (elements[0].el.textContent = stats.totalGames);
                elements[1].el && (elements[1].el.textContent = stats.winCount);
                elements[2].el && (elements[2].el.textContent = this.formatNumber(stats.totalReward));
                
                const winRate = stats.totalGames > 0 ? ((stats.winCount / stats.totalGames) * 100).toFixed(1) : 0;
                elements[3].el && (elements[3].el.textContent = `${winRate}%`);
            }

            startWheelAnimation() {
                document.getElementById('wheel')?.classList.add('spinning');
            }

            stopWheelAnimation() {
                document.getElementById('wheel')?.classList.remove('spinning');
            }

            showResult(result, txHash = null) {
                this.stopWheelAnimation();
                this.state.isSpinning = false;
                this.updateGameUI(false);

                const elements = {
                    modal: document.getElementById('resultModal'),
                    icon: document.getElementById('resultIcon'),
                    title: document.getElementById('resultTitle'),
                    message: document.getElementById('resultMessage'),
                    reward: document.getElementById('resultReward'),
                    txHash: document.getElementById('txHash')
                };

                if (Object.values(elements).every(el => el)) {
                    if (result.isWin) {
                        elements.icon.textContent = 'ğŸ‰';
                        elements.title.textContent = 'ğŸ”— åŒºå—é“¾ä¸­å¥–ï¼';
                        elements.message.textContent = `ç­‰çº§ ${result.rewardLevel} - çœŸå®å¥–åŠ±å·²å‘æ”¾`;
                        elements.reward.textContent = `+${this.formatNumber(result.reward)} ${this.state.selectedToken}`;
                    } else {
                        elements.icon.textContent = 'ğŸ¯';
                        elements.title.textContent = 'ç»§ç»­å°è¯•';
                        elements.message.textContent = 'è¿™æ¬¡è¿æ°”ç¨å·®ï¼Œä¸‹æ¬¡ä¼šæ›´å¥½ï¼';
                        elements.reward.textContent = 'å†è¯•ä¸€æ¬¡';
                    }

                    if (txHash) {
                        elements.txHash.innerHTML = `<a href="https://alveyscan.com/tx/${txHash}" target="_blank" class="text-blue-300 hover:text-blue-100">æŸ¥çœ‹äº¤æ˜“: ${txHash.slice(0, 16)}...</a>`;
                    }

                    elements.modal.classList.remove('hidden');
                    setTimeout(() => this.updateBalances(), 2000);
                }
            }

            async connectWallet() {
                try {
                    if (!window.ethereum) {
                        throw new Error('éœ€è¦å®‰è£… MetaMask');
                    }

                    this.setGameStatus('è¿æ¥çœŸå®åŒºå—é“¾é’±åŒ…...', 'info');

                    const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                    if (!accounts.length) return;

                    // ğŸ”§ ä¿®å¤çš„ç½‘ç»œé…ç½® - AlveyChain
                    const chainId = await window.ethereum.request({ method: 'eth_chainId' });
                    const targetChainId = '0xED5'; // 3797 hex
                    
                    if (chainId !== targetChainId) {
                        try {
                            await window.ethereum.request({
                                method: 'wallet_switchEthereumChain',
                                params: [{ chainId: targetChainId }]
                            });
                        } catch (switchError) {
                            if (switchError.code === 4902) {
                                await window.ethereum.request({
                                    method: 'wallet_addEthereumChain',
                                    params: [{
                                        chainId: targetChainId,
                                        chainName: 'AlveyChain Mainnet',
                                        nativeCurrency: { name: 'ALV', symbol: 'ALV', decimals: 18 },
                                        rpcUrls: ['https://elves-core1.alvey.io'],
                                        blockExplorerUrls: ['https://alveyscan.com']
                                    }]
                                });
                            }
                        }
                    }

                    // åˆå§‹åŒ–é’±åŒ…
                    this.state.wallet = {
                        address: accounts[0],
                        provider: new ethers.providers.Web3Provider(window.ethereum),
                        connected: true
                    };
                    this.state.wallet.signer = this.state.wallet.provider.getSigner();

                    // ğŸ”§ ä¿®å¤çš„åˆçº¦åˆå§‹åŒ– - æ·»åŠ é”™è¯¯å¤„ç†
                    try {
                        this.state.contracts.mao = new ethers.Contract(
                            this.addresses.MAO_TOKEN, 
                            this.tokenABI, 
                            this.state.wallet.signer
                        );
                        this.state.contracts.pi = new ethers.Contract(
                            this.addresses.PI_TOKEN, 
                            this.tokenABI, 
                            this.state.wallet.signer
                        );
                        this.state.contracts.wheelGame = new ethers.Contract(
                            this.addresses.WHEEL_GAME, 
                            this.wheelGameABI, 
                            this.state.wallet.signer
                        );

                        this.updateWalletUI();
                        await this.updateBalances();
                        await this.loadBlockchainStats();
                        this.setGameStatus('ğŸš€ çœŸå®åŒºå—é“¾å·²è¿æ¥ï¼Œå‡†å¤‡å¼€å§‹æ¸¸æˆ', 'success');

                    } catch (contractError) {
                        console.error('åˆçº¦åˆå§‹åŒ–é”™è¯¯:', contractError);
                        this.setGameStatus('åˆçº¦è¿æ¥å¤±è´¥ï¼Œè¯·åˆ·æ–°é‡è¯•', 'error');
                    }

                } catch (error) {
                    console.error('é’±åŒ…è¿æ¥é”™è¯¯:', error);
                    this.setGameStatus(`è¿æ¥å¤±è´¥: ${error.message}`, 'error');
                }
            }

            updateWalletUI() {
                const disconnected = document.getElementById('walletDisconnected');
                const connected = document.getElementById('walletConnected');
                
                if (this.state.wallet.connected) {
                    disconnected?.classList.add('hidden');
                    connected?.classList.remove('hidden');
                    const walletAddr = document.getElementById('walletAddress');
                    if (walletAddr) walletAddr.textContent = this.formatAddress(this.state.wallet.address);
                } else {
                    disconnected?.classList.remove('hidden');
                    connected?.classList.add('hidden');
                }
            }

            async updateBalances() {
                if (!this.state.wallet.connected || !this.state.contracts.mao) return;

                try {
                    const [maoBalance, piBalance] = await Promise.all([
                        this.state.contracts.mao.balanceOf(this.state.wallet.address),
                        this.state.contracts.pi.balanceOf(this.state.wallet.address)
                    ]);

                    const maoEl = document.getElementById('maoBalance');
                    const piEl = document.getElementById('piBalance');
                    
                    if (maoEl) maoEl.textContent = this.formatNumber(ethers.utils.formatEther(maoBalance));
                    if (piEl) piEl.textContent = this.formatNumber(ethers.utils.formatEther(piBalance));
                } catch (error) {
                    console.error('æ›´æ–°ä½™é¢å¤±è´¥:', error);
                }
            }

            async loadBlockchainStats() {
                if (!this.state.contracts.wheelGame) return;

                try {
                    const playerHistory = await this.state.contracts.wheelGame.getPlayerHistory(this.state.wallet.address);

                    let totalGames = 0;
                    let winCount = 0;
                    let totalReward = 0;

                    playerHistory.forEach(game => {
                        totalGames++;
                        if (game.rewardAmount.gt(0)) {
                            winCount++;
                            totalReward += parseFloat(ethers.utils.formatEther(game.rewardAmount));
                        }
                    });

                    this.state.stats = { totalGames, winCount, totalReward };
                    this.updateStats();

                } catch (error) {
                    console.error('åŠ è½½åŒºå—é“¾ç»Ÿè®¡å¤±è´¥:', error);
                }
            }

            // ğŸ”§ ä¿®å¤çš„æ¸¸æˆé€»è¾‘ - æ”¹è¿›é”™è¯¯å¤„ç†
            async startRealBlockchainGame() {
                if (!this.state.wallet.connected) {
                    this.setGameStatus('è¯·å…ˆè¿æ¥é’±åŒ…å¯åŠ¨åŒºå—é“¾æ¸¸æˆ', 'warning');
                    return;
                }

                if (this.state.isSpinning) return;

                try {
                    this.state.isSpinning = true;
                    this.updateGameUI(true);

                    const { selectedToken } = this.state;
                    const tokenContract = selectedToken === 'MAO' ? this.state.contracts.mao : this.state.contracts.pi;
                    const amount = ethers.utils.parseEther(selectedToken === 'MAO' ? '100' : '1000');
                    
                    // ğŸ”§ æ”¹è¿›çš„ä½™é¢æ£€æŸ¥
                    this.setGameStatus('ğŸ”— æ£€æŸ¥åŒºå—é“¾ä½™é¢...', 'info');
                    const balance = await tokenContract.balanceOf(this.state.wallet.address);
                    if (balance.lt(amount)) {
                        throw new Error(`ä½™é¢ä¸è¶³ï¼éœ€è¦ ${selectedToken === 'MAO' ? '100' : '1000'} ${selectedToken}`);
                    }

                    // ğŸ”§ æ”¹è¿›çš„æˆæƒæ£€æŸ¥
                    this.setGameStatus('ğŸ”— æ£€æŸ¥åˆçº¦æˆæƒ...', 'info');
                    const allowance = await tokenContract.allowance(this.state.wallet.address, this.addresses.WHEEL_GAME);
                    if (allowance.lt(amount)) {
                        this.setGameStatus('ğŸ”— æˆæƒåˆçº¦è®¿é—®ä»£å¸...', 'info');
                        const approveTx = await tokenContract.approve(this.addresses.WHEEL_GAME, ethers.constants.MaxUint256);
                        await approveTx.wait(2); // ç­‰å¾…2ä¸ªç¡®è®¤
                        this.setGameStatus('âœ… æˆæƒæˆåŠŸ', 'success');
                    }

                    this.setGameStatus('ğŸ° å¯åŠ¨çœŸå®åŒºå—é“¾è½¬ç›˜...', 'info');
                    this.startWheelAnimation();
                    
                    // ğŸ”§ æ”¹è¿›çš„åˆçº¦è°ƒç”¨ - è®¾ç½®Gasé™åˆ¶
                    let gameTx;
                    const gasLimit = selectedToken === 'MAO' ? 300000 : 350000; // è®¾ç½®Gasé™åˆ¶
                    
                    if (selectedToken === 'MAO') {
                        gameTx = await this.state.contracts.wheelGame.playMAOGame({ gasLimit });
                    } else {
                        gameTx = await this.state.contracts.wheelGame.playPIGame({ gasLimit });
                    }

                    this.setGameStatus('â›ï¸ åŒºå—é“¾ç¡®è®¤ä¸­...è¯·ç¨å€™', 'info');
                    const receipt = await gameTx.wait(3); // ç­‰å¾…3ä¸ªç¡®è®¤

                    // ğŸ”§ æ”¹è¿›çš„äº‹ä»¶è§£æ - å…¼å®¹AlveyChain
                    let gameResult = null;
                    
                    try {
                        // æ–¹æ³•1ï¼šå°è¯•è§£æäº‹ä»¶
                        if (receipt.events && receipt.events.length > 0) {
                            const gamePlayedEvent = receipt.events.find(e => e.event === 'GamePlayed');
                            if (gamePlayedEvent && gamePlayedEvent.args) {
                                const { rewardAmount, rewardLevel } = gamePlayedEvent.args;
                                gameResult = {
                                    isWin: rewardAmount.gt(0),
                                    reward: ethers.utils.formatEther(rewardAmount),
                                    rewardLevel: rewardLevel.toString()
                                };
                            }
                        }
                        
                        // æ–¹æ³•2ï¼šå¦‚æœäº‹ä»¶è§£æå¤±è´¥ï¼Œåˆ†æäº¤æ˜“æ—¥å¿—
                        if (!gameResult && receipt.logs && receipt.logs.length > 0) {
                            for (const log of receipt.logs) {
                                try {
                                    const parsedLog = this.state.contracts.wheelGame.interface.parseLog(log);
                                    if (parsedLog.name === 'GamePlayed') {
                                        const { rewardAmount, rewardLevel } = parsedLog.args;
                                        gameResult = {
                                            isWin: rewardAmount.gt(0),
                                            reward: ethers.utils.formatEther(rewardAmount),
                                            rewardLevel: rewardLevel.toString()
                                        };
                                        break;
                                    }
                                } catch (parseError) {
                                    continue; // å¿½ç•¥æ— æ³•è§£æçš„æ—¥å¿—
                                }
                            }
                        }
                        
                        // æ–¹æ³•3ï¼šå¦‚æœä»ç„¶æ— æ³•è§£æï¼ŒæŸ¥è¯¢æ¸¸æˆå†å²
                        if (!gameResult) {
                            this.setGameStatus('ğŸ“Š æŸ¥è¯¢æ¸¸æˆç»“æœ...', 'info');
                            const newHistory = await this.state.contracts.wheelGame.getPlayerHistory(this.state.wallet.address);
                            if (newHistory.length > 0) {
                                const lastGame = newHistory[newHistory.length - 1];
                                if (lastGame.timestamp.toNumber() > Date.now() / 1000 - 60) { // æœ€è¿‘1åˆ†é’Ÿçš„æ¸¸æˆ
                                    gameResult = {
                                        isWin: lastGame.rewardAmount.gt(0),
                                        reward: ethers.utils.formatEther(lastGame.rewardAmount),
                                        rewardLevel: lastGame.rewardLevel.toString()
                                    };
                                }
                            }
                        }

                    } catch (parseError) {
                        console.error('äº‹ä»¶è§£æé”™è¯¯:', parseError);
                    }

                    // æ˜¾ç¤ºç»“æœ
                    if (gameResult) {
                        setTimeout(() => {
                            this.showResult(gameResult, gameTx.hash);
                            this.loadBlockchainStats();
                        }, 1000);
                    } else {
                        // å¦‚æœæ— æ³•ç¡®å®šç»“æœï¼Œæ˜¾ç¤ºæˆåŠŸä½†æ— æ³•è§£æ
                        setTimeout(() => {
                            this.showResult({
                                isWin: false,
                                reward: '0',
                                rewardLevel: '0',
                                message: 'æ¸¸æˆå®Œæˆä½†ç»“æœè§£æå¤±è´¥'
                            }, gameTx.hash);
                            this.loadBlockchainStats();
                        }, 1000);
                    }

                } catch (error) {
                    console.error('æ¸¸æˆé”™è¯¯:', error);
                    let errorMsg = error.message;
                    
                    // ğŸ”§ æ”¹è¿›çš„é”™è¯¯æ¶ˆæ¯å¤„ç†
                    if (errorMsg.includes('insufficient funds') || errorMsg.includes('Insufficient')) {
                        errorMsg = 'ä½™é¢ä¸è¶³ï¼Œè¯·ç¡®ä¿æœ‰è¶³å¤Ÿçš„ä»£å¸å’ŒGasè´¹ç”¨';
                    } else if (errorMsg.includes('user rejected') || errorMsg.includes('denied')) {
                        errorMsg = 'ç”¨æˆ·å–æ¶ˆäº†äº¤æ˜“';
                    } else if (errorMsg.includes('allowance') || errorMsg.includes('Allowance')) {
                        errorMsg = 'ä»£å¸æˆæƒå¤±è´¥ï¼Œè¯·é‡è¯•';
                    } else if (errorMsg.includes('CALL_EXCEPTION')) {
                        errorMsg = 'æ™ºèƒ½åˆçº¦è°ƒç”¨å¤±è´¥ï¼Œå¯èƒ½æ˜¯ç½‘ç»œé—®é¢˜ï¼Œè¯·é‡è¯•';
                    } else if (errorMsg.includes('nonce')) {
                        errorMsg = 'äº¤æ˜“åºå·å†²çªï¼Œè¯·ç¨åé‡è¯•';
                    } else if (errorMsg.includes('gas')) {
                        errorMsg = 'Gasè´¹ç”¨ä¸è¶³ï¼Œè¯·å¢åŠ Gasè´¹ç”¨';
                    }

                    this.setGameStatus(`æ¸¸æˆé”™è¯¯: ${errorMsg}`, 'error');
                    this.stopWheelAnimation();
                    this.state.isSpinning = false;
                    this.updateGameUI(false);
                }
            }

            initialize() {
                document.addEventListener('DOMContentLoaded', () => {
                    this.setupEventListeners();
                    this.updateTokenSelection();
                    this.updateStats();
                    this.setGameStatus('ğŸ”— çœŸå®åŒºå—é“¾æ¸¸æˆå°±ç»ª', 'success');
                });

                // MetaMaskäº‹ä»¶ç›‘å¬
                if (window.ethereum) {
                    window.ethereum.on('accountsChanged', (accounts) => {
                        if (accounts.length === 0) {
                            this.state.wallet.connected = false;
                            this.updateWalletUI();
                        } else {
                            this.connectWallet();
                        }
                    });

                    window.ethereum.on('chainChanged', () => {
                        this.setGameStatus('ç½‘ç»œå·²åˆ‡æ¢ï¼Œé‡æ–°åŠ è½½...', 'info');
                        setTimeout(() => window.location.reload(), 1000);
                    });
                }

                // å…¨å±€é”™è¯¯å¤„ç†
                window.addEventListener('error', (event) => {
                    console.error('æ¸¸æˆé”™è¯¯:', event.error);
                });
            }

            setupEventListeners() {
                document.getElementById('connectBtn')?.addEventListener('click', () => this.connectWallet());

                document.getElementById('selectMao')?.addEventListener('click', () => {
                    this.state.selectedToken = 'MAO';
                    this.updateTokenSelection();
                    this.setGameStatus('ğŸ± MAOåŒºå—é“¾æ¨¡å¼å·²æ¿€æ´»', 'info');
                });
                
                document.getElementById('selectPi')?.addEventListener('click', () => {
                    this.state.selectedToken = 'PI';
                    this.updateTokenSelection();
                    this.setGameStatus('ğŸ¥§ PIåŒºå—é“¾æ¨¡å¼å·²æ¿€æ´»', 'info');
                });

                document.getElementById('spinBtn')?.addEventListener('click', () => this.startRealBlockchainGame());

                document.getElementById('closeModal')?.addEventListener('click', () => {
                    document.getElementById('resultModal')?.classList.add('hidden');
                });
            }
        }

        // ğŸš€ å¯åŠ¨ä¿®å¤ç‰ˆçœŸå®åŒºå—é“¾æ¸¸æˆç³»ç»Ÿ
        const fixedGameEngine = new FixedBlockchainGameEngine();
        fixedGameEngine.initialize();
    </script>
</body>
</html>
