<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ° MAO Real Blockchain Wheel - v8.5 MULTI-RPC</title>
    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { background: linear-gradient(135deg, #667eea, #764ba2); min-height: 100vh; font-family: Inter, sans-serif; }
        .glass { background: rgba(255,255,255,0.15); backdrop-filter: blur(20px); border: 1px solid rgba(255,255,255,0.3); }
        .wheel { width: 300px; height: 300px; border-radius: 50%; background: conic-gradient(from 0deg, #ef4444 0deg 180deg, #10b981 180deg 360deg); transition: transform 4s ease; position: relative; }
        .spinning { animation: spin 4s ease; }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(1800deg); } }
        .token-btn { padding: 12px 24px; border-radius: 12px; cursor: pointer; transition: all 0.3s; }
        .token-btn.active { background: linear-gradient(135deg, #f59e0b, #fbbf24); color: black; }
        .game-btn { background: linear-gradient(135deg, #10b981, #059669); color: white; padding: 16px 32px; border-radius: 16px; font-weight: bold; cursor: pointer; transition: all 0.3s; }
        .loading { width: 20px; height: 20px; border: 2px solid #fff; border-top: 2px solid #f59e0b; border-radius: 50%; animation: rotate 1s linear infinite; }
        @keyframes rotate { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
    </style>
</head>
<body class="text-white">
    <div class="container mx-auto p-8">
        <h1 class="text-4xl font-bold text-center mb-8">ğŸ° MAO Real Blockchain Game</h1>
        
        <!-- Status Bar -->
        <div class="glass rounded-2xl p-4 mb-6">
            <div class="flex items-center justify-center">
                <span id="networkStatus" class="text-sm">ğŸ”— åˆå§‹åŒ–å¤šèŠ‚ç‚¹åŒºå—é“¾ç³»ç»Ÿ...</span>
            </div>
        </div>
        
        <!-- Wallet Section -->
        <div class="glass rounded-2xl p-6 mb-8">
            <div id="walletDisconnected">
                <button id="connectBtn" class="game-btn mx-auto block">è¿æ¥ MetaMask é’±åŒ…</button>
            </div>
            <div id="walletConnected" class="hidden">
                <div class="text-center mb-4">
                    <span class="text-green-400">é’±åŒ…å·²è¿æ¥:</span>
                    <span id="walletAddress" class="font-mono"></span>
                </div>
                <div class="grid grid-cols-2 gap-4 mb-6">
                    <div class="glass rounded-xl p-4 text-center">
                        <div class="text-2xl mb-2">ğŸ±</div>
                        <div class="text-yellow-400 text-2xl font-bold" id="maoBalance">0</div>
                        <div class="text-sm">MAO</div>
                    </div>
                    <div class="glass rounded-xl p-4 text-center">
                        <div class="text-2xl mb-2">ğŸ¥§</div>
                        <div class="text-green-400 text-2xl font-bold" id="piBalance">0</div>
                        <div class="text-sm">PI</div>
                    </div>
                </div>
                
                <!-- Token Selection -->
                <div class="flex justify-center mb-6">
                    <div class="glass rounded-xl p-2 flex gap-2">
                        <button id="selectMao" class="token-btn active">ğŸ± MAO (100)</button>
                        <button id="selectPi" class="token-btn">ğŸ¥§ PI (1000)</button>
                    </div>
                </div>
                
                <!-- Wheel -->
                <div class="flex justify-center mb-6">
                    <div class="relative">
                        <div class="wheel" id="wheel">
                            <div class="absolute inset-0 flex items-center justify-center">
                                <div class="w-16 h-16 bg-white rounded-full flex items-center justify-center">
                                    <span class="text-2xl">ğŸ¯</span>
                                </div>
                            </div>
                        </div>
                        <div class="absolute top-0 left-1/2 transform -translate-x-1/2 -translate-y-2">
                            <div class="w-0 h-0 border-l-4 border-r-4 border-b-8 border-transparent border-b-yellow-400"></div>
                        </div>
                    </div>
                </div>
                
                <!-- Game Button -->
                <div class="text-center">
                    <button id="spinBtn" class="game-btn">ğŸ² çœŸå®åŒºå—é“¾è½¬ç›˜</button>
                    <div id="gameStatus" class="mt-4 text-sm">âœ… å¤šèŠ‚ç‚¹åŒºå—é“¾ç³»ç»Ÿå·²å°±ç»ª</div>
                </div>
            </div>
        </div>
        
        <!-- Stats -->
        <div class="glass rounded-2xl p-6">
            <h3 class="text-xl font-semibold mb-4">ğŸ“Š çœŸå®åŒºå—é“¾ç»Ÿè®¡</h3>
            <div class="grid grid-cols-4 gap-4">
                <div class="text-center">
                    <div class="text-2xl font-bold text-blue-400" id="totalGames">0</div>
                    <div class="text-sm">æ€»å±€æ•°</div>
                </div>
                <div class="text-center">
                    <div class="text-2xl font-bold text-green-400" id="winCount">0</div>
                    <div class="text-sm">èƒœåˆ©æ•°</div>
                </div>
                <div class="text-center">
                    <div class="text-2xl font-bold text-yellow-400" id="winRate">0%</div>
                    <div class="text-sm">èƒœç‡</div>
                </div>
                <div class="text-center">
                    <div class="text-2xl font-bold text-purple-400" id="totalReward">0</div>
                    <div class="text-sm">æ€»å¥–åŠ±</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Result Modal -->
    <div id="resultModal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center hidden">
        <div class="glass rounded-2xl p-8 max-w-md text-center">
            <div id="resultIcon" class="text-6xl mb-4"></div>
            <h3 id="resultTitle" class="text-2xl font-bold mb-2"></h3>
            <p id="resultMessage" class="mb-4"></p>
            <div id="resultReward" class="text-3xl font-bold text-yellow-400 mb-6"></div>
            <div id="txHash" class="text-xs text-blue-300 mb-4 font-mono break-all"></div>
            <button id="closeModal" class="game-btn">ç»§ç»­æ¸¸æˆ</button>
        </div>
    </div>

    <script>
        // ğŸ”— å¤šèŠ‚ç‚¹çœŸå®åŒºå—é“¾æ¸¸æˆå¼•æ“ v8.5 MULTI-RPC
        class MultiRpcBlockchainGameEngine {
            constructor() {
                this.state = {
                    wallet: { connected: false, address: null, provider: null, signer: null },
                    selectedToken: 'MAO',
                    isPlaying: false,
                    stats: { totalGames: 0, winCount: 0, totalReward: 0 },
                    contracts: { mao: null, pi: null, wheelGame: null },
                    currentRpcIndex: 0
                };
                
                this.addresses = {
                    MAO_TOKEN: "0x22f49bcb3dad370a9268ba3fca33cb037ca3d022",
                    PI_TOKEN: "0xfd4680e25e05b3435c7f698668d1ce80d2a9f444",
                    WHEEL_GAME: "0x621DF9e0DE6b4e7EDC5Dc22Cd7c0F883c3F56966"
                };

                // ğŸ”§ ä¿®å¤ï¼šä½¿ç”¨å¤šä¸ªRPCèŠ‚ç‚¹ï¼Œcore1æœ‰é—®é¢˜åˆ™ä½¿ç”¨core2/core3
                this.rpcNodes = [
                    'https://elves-core2.alvey.io', // ä¼˜å…ˆä½¿ç”¨core2
                    'https://elves-core3.alvey.io', // å¤‡ç”¨core3
                    'https://elves-core1.alvey.io'  // core1ä½œä¸ºæœ€åå¤‡ç”¨
                ];

                this.networkConfig = {
                    chainId: '0xED5', // 3797
                    chainName: 'AlveyChain Mainnet',
                    nativeCurrency: { name: 'ALV', symbol: 'ALV', decimals: 18 },
                    rpcUrls: this.rpcNodes,
                    blockExplorerUrls: ['https://alveyscan.com']
                };

                this.tokenABI = [
                    "function balanceOf(address owner) external view returns (uint256)",
                    "function approve(address spender, uint256 amount) external returns (bool)",
                    "function allowance(address owner, address spender) external view returns (uint256)",
                    "function symbol() external view returns (string)"
                ];

                this.gameABI = [
                    "function playMAOGame() external",
                    "function playPIGame() external",
                    "function getPlayerHistory(address player) external view returns (tuple(address player, uint8 tokenType, uint256 betAmount, uint256 rewardAmount, uint8 rewardLevel, uint256 timestamp, uint256 randomSeed, bool wasProtected)[])",
                    "function getGameStats(uint8 tokenType) external view returns (tuple(uint256 totalGames, uint256 totalWins, uint256 totalBets, uint256 totalRewards, uint256 protectedGames))",
                    "event GamePlayed(address indexed player, uint8 tokenType, uint256 betAmount, uint256 rewardAmount, uint8 rewardLevel, uint256 randomSeed, bool wasProtected)"
                ];
            }

            formatAddress(addr) {
                return addr ? `${addr.slice(0, 6)}...${addr.slice(-4)}` : '';
            }

            formatNumber(num) {
                return Math.floor(Number(num)).toLocaleString();
            }

            setStatus(message, type = 'info') {
                const el = document.getElementById('gameStatus');
                if (el) {
                    const icons = { info: 'ğŸ”—', success: 'âœ…', warning: 'âš ï¸', error: 'âŒ', loading: 'â³' };
                    el.innerHTML = `${icons[type]} ${message}`;
                }
            }

            setNetwork(message, type = 'info') {
                const el = document.getElementById('networkStatus');
                if (el) {
                    const icons = { info: 'ğŸ”—', success: 'ğŸŸ¢', warning: 'ğŸŸ¡', error: 'ğŸ”´' };
                    el.innerHTML = `${icons[type]} ${message}`;
                }
            }

            updateTokens() {
                const mao = document.getElementById('selectMao');
                const pi = document.getElementById('selectPi');
                
                if (this.state.selectedToken === 'MAO') {
                    mao?.classList.add('active');
                    pi?.classList.remove('active');
                } else {
                    mao?.classList.remove('active');
                    pi?.classList.add('active');
                }
            }

            updateUI(playing) {
                const btn = document.getElementById('spinBtn');
                const tokens = document.querySelectorAll('.token-btn');
                
                if (playing) {
                    btn.disabled = true;
                    btn.innerHTML = '<div class="loading mx-auto"></div>';
                    tokens.forEach(t => t.disabled = true);
                } else {
                    btn.disabled = false;
                    btn.innerHTML = 'ğŸ² çœŸå®åŒºå—é“¾è½¬ç›˜';
                    tokens.forEach(t => t.disabled = false);
                }
            }

            updateStats() {
                const { stats } = this.state;
                const els = ['totalGames', 'winCount', 'totalReward', 'winRate'];
                
                document.getElementById(els[0]).textContent = stats.totalGames;
                document.getElementById(els[1]).textContent = stats.winCount;
                document.getElementById(els[2]).textContent = this.formatNumber(stats.totalReward);
                
                const rate = stats.totalGames > 0 ? ((stats.winCount / stats.totalGames) * 100).toFixed(1) : 0;
                document.getElementById(els[3]).textContent = `${rate}%`;
            }

            startSpin() {
                document.getElementById('wheel')?.classList.add('spinning');
            }

            stopSpin() {
                document.getElementById('wheel')?.classList.remove('spinning');
            }

            showResult(result, hash) {
                this.stopSpin();
                this.state.isPlaying = false;
                this.updateUI(false);

                const modal = document.getElementById('resultModal');
                const icon = document.getElementById('resultIcon');
                const title = document.getElementById('resultTitle');
                const msg = document.getElementById('resultMessage');
                const reward = document.getElementById('resultReward');
                const tx = document.getElementById('txHash');

                if (result.isWin) {
                    icon.textContent = 'ğŸ‰';
                    title.textContent = 'ğŸŠ çœŸå®åŒºå—é“¾ä¸­å¥–ï¼';
                    msg.textContent = `ç­‰çº§ ${result.level} - çœŸå®å¥–åŠ±å·²å‘æ”¾åˆ°é’±åŒ…`;
                    reward.textContent = `+${this.formatNumber(result.amount)} ${this.state.selectedToken}`;
                } else {
                    icon.textContent = 'ğŸ¯';
                    title.textContent = 'çœŸå®åŒºå—é“¾æ¸¸æˆ';
                    msg.textContent = 'è¿™æ¬¡æ²¡ä¸­å¥–ï¼Œä½†æ˜¯çœŸå®çš„åŒºå—é“¾äº¤æ˜“ï¼';
                    reward.textContent = 'ç»§ç»­çœŸå®æ¸¸æˆ';
                }

                if (hash) {
                    tx.innerHTML = `<a href="https://alveyscan.com/tx/${hash}" target="_blank" class="text-blue-300">æŸ¥çœ‹çœŸå®äº¤æ˜“: ${hash.slice(0, 16)}...</a>`;
                } else {
                    tx.textContent = '';
                }

                modal.classList.remove('hidden');
                setTimeout(() => this.updateBalances(), 1000);
            }

            // ğŸ”§ æ™ºèƒ½RPCèŠ‚ç‚¹æµ‹è¯•å’Œåˆ‡æ¢
            async testRpcNode(rpcUrl) {
                try {
                    const provider = new ethers.providers.JsonRpcProvider(rpcUrl);
                    await provider.getBlockNumber();
                    return true;
                } catch (error) {
                    console.error(`RPCèŠ‚ç‚¹ ${rpcUrl} æµ‹è¯•å¤±è´¥:`, error);
                    return false;
                }
            }

            async findWorkingRpcNode() {
                this.setNetwork('æµ‹è¯•RPCèŠ‚ç‚¹è¿æ¥...', 'info');
                
                for (let i = 0; i < this.rpcNodes.length; i++) {
                    const rpcUrl = this.rpcNodes[i];
                    this.setNetwork(`æµ‹è¯•èŠ‚ç‚¹ ${i + 1}/${this.rpcNodes.length}: ${rpcUrl}`, 'info');
                    
                    const isWorking = await this.testRpcNode(rpcUrl);
                    if (isWorking) {
                        this.state.currentRpcIndex = i;
                        this.setNetwork(`ğŸŸ¢ è¿æ¥æˆåŠŸ: ${rpcUrl}`, 'success');
                        return rpcUrl;
                    }
                }
                
                throw new Error('æ‰€æœ‰RPCèŠ‚ç‚¹éƒ½æ— æ³•è¿æ¥');
            }

            async setupNetwork() {
                try {
                    this.setNetwork('åˆå§‹åŒ–å¤šèŠ‚ç‚¹AlveyChain...', 'info');
                    
                    if (!window.ethereum) {
                        throw new Error('è¯·å®‰è£… MetaMask æ‰èƒ½è¿›è¡ŒçœŸå®åŒºå—é“¾æ¸¸æˆ');
                    }

                    // ğŸ”§ æ‰¾åˆ°å¯ç”¨çš„RPCèŠ‚ç‚¹
                    const workingRpc = await this.findWorkingRpcNode();

                    const chainId = await window.ethereum.request({ method: 'eth_chainId' });
                    const target = '0xED5'; // AlveyChain 3797
                    
                    if (chainId !== target) {
                        this.setNetwork('åˆ‡æ¢åˆ° AlveyChain ä¸»ç½‘...', 'warning');
                        
                        try {
                            await window.ethereum.request({
                                method: 'wallet_switchEthereumChain',
                                params: [{ chainId: target }]
                            });
                        } catch (switchError) {
                            if (switchError.code === 4902) {
                                // ä½¿ç”¨å¯ç”¨çš„RPCèŠ‚ç‚¹æ·»åŠ ç½‘ç»œ
                                await window.ethereum.request({
                                    method: 'wallet_addEthereumChain',
                                    params: [{
                                        chainId: target,
                                        chainName: 'AlveyChain Mainnet',
                                        nativeCurrency: { name: 'ALV', symbol: 'ALV', decimals: 18 },
                                        rpcUrls: [workingRpc], // ä½¿ç”¨å¯ç”¨çš„RPC
                                        blockExplorerUrls: ['https://alveyscan.com']
                                    }]
                                });
                            }
                        }
                    }

                    // å†æ¬¡æµ‹è¯•è¿æ¥
                    const provider = new ethers.providers.Web3Provider(window.ethereum);
                    await provider.getBlockNumber();

                    this.setNetwork(`ğŸŸ¢ AlveyChain å¤šèŠ‚ç‚¹ç³»ç»Ÿå·²è¿æ¥ (ä½¿ç”¨èŠ‚ç‚¹${this.state.currentRpcIndex + 1})`, 'success');
                    return true;

                } catch (error) {
                    console.error('ç½‘ç»œè®¾ç½®å¤±è´¥:', error);
                    this.setNetwork(`âŒ ç½‘ç»œé”™è¯¯: ${error.message}`, 'error');
                    return false;
                }
            }

            async connectWallet() {
                try {
                    const networkOk = await this.setupNetwork();
                    if (!networkOk) {
                        this.setStatus('è¯·å…ˆæ­£ç¡®è¿æ¥AlveyChainç½‘ç»œ', 'error');
                        return;
                    }

                    this.setStatus('è¿æ¥çœŸå®åŒºå—é“¾é’±åŒ…...', 'loading');

                    const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                    if (!accounts.length) {
                        this.setStatus('è¯·æˆæƒé’±åŒ…è¿æ¥', 'warning');
                        return;
                    }

                    this.state.wallet = {
                        address: accounts[0],
                        provider: new ethers.providers.Web3Provider(window.ethereum),
                        connected: true
                    };
                    this.state.wallet.signer = this.state.wallet.provider.getSigner();

                    // åˆå§‹åŒ–çœŸå®æ™ºèƒ½åˆçº¦
                    this.setStatus('åˆå§‹åŒ–çœŸå®æ™ºèƒ½åˆçº¦...', 'loading');
                    
                    this.state.contracts.mao = new ethers.Contract(this.addresses.MAO_TOKEN, this.tokenABI, this.state.wallet.signer);
                    this.state.contracts.pi = new ethers.Contract(this.addresses.PI_TOKEN, this.tokenABI, this.state.wallet.signer);
                    this.state.contracts.wheelGame = new ethers.Contract(this.addresses.WHEEL_GAME, this.gameABI, this.state.wallet.signer);

                    // éªŒè¯åˆçº¦è¿æ¥
                    await Promise.all([
                        this.state.contracts.mao.symbol(),
                        this.state.contracts.pi.symbol(),
                        this.state.contracts.wheelGame.getPlayerHistory(this.state.wallet.address)
                    ]);

                    this.updateWallet();
                    await this.updateBalances();
                    await this.loadStats();
                    this.setStatus('ğŸš€ å¤šèŠ‚ç‚¹çœŸå®åŒºå—é“¾ç³»ç»Ÿå·²å®Œå…¨è¿æ¥', 'success');

                } catch (error) {
                    console.error('é’±åŒ…è¿æ¥å¤±è´¥:', error);
                    this.setStatus(`è¿æ¥å¤±è´¥: ${error.message}`, 'error');
                }
            }

            updateWallet() {
                const disc = document.getElementById('walletDisconnected');
                const conn = document.getElementById('walletConnected');
                
                if (this.state.wallet.connected) {
                    disc?.classList.add('hidden');
                    conn?.classList.remove('hidden');
                    document.getElementById('walletAddress').textContent = this.formatAddress(this.state.wallet.address);
                } else {
                    disc?.classList.remove('hidden');
                    conn?.classList.add('hidden');
                }
            }

            async updateBalances() {
                if (!this.state.wallet.connected) return;

                try {
                    const [maoBalance, piBalance] = await Promise.all([
                        this.state.contracts.mao.balanceOf(this.state.wallet.address),
                        this.state.contracts.pi.balanceOf(this.state.wallet.address)
                    ]);

                    document.getElementById('maoBalance').textContent = this.formatNumber(ethers.utils.formatEther(maoBalance));
                    document.getElementById('piBalance').textContent = this.formatNumber(ethers.utils.formatEther(piBalance));
                } catch (error) {
                    console.error('æ›´æ–°ä½™é¢å¤±è´¥:', error);
                    this.setStatus('ä½™é¢æŸ¥è¯¢å¤±è´¥ï¼Œå°è¯•åˆ‡æ¢RPCèŠ‚ç‚¹', 'warning');
                }
            }

            async loadStats() {
                if (!this.state.contracts.wheelGame) return;

                try {
                    const history = await this.state.contracts.wheelGame.getPlayerHistory(this.state.wallet.address);

                    let totalGames = 0;
                    let winCount = 0;
                    let totalReward = 0;

                    history.forEach(game => {
                        totalGames++;
                        if (game.rewardAmount.gt(0)) {
                            winCount++;
                            totalReward += parseFloat(ethers.utils.formatEther(game.rewardAmount));
                        }
                    });

                    this.state.stats = { totalGames, winCount, totalReward };
                    this.updateStats();

                } catch (error) {
                    console.error('åŠ è½½ç»Ÿè®¡å¤±è´¥:', error);
                }
            }

            // ğŸ”§ æ™ºèƒ½åˆçº¦è°ƒç”¨é‡è¯•æœºåˆ¶
            async executeContractCall(contractCall, retries = 3) {
                for (let attempt = 1; attempt <= retries; attempt++) {
                    try {
                        this.setStatus(`æ‰§è¡ŒåŒºå—é“¾äº¤æ˜“ (å°è¯• ${attempt}/${retries})...`, 'loading');
                        return await contractCall();
                    } catch (error) {
                        console.error(`äº¤æ˜“å°è¯• ${attempt} å¤±è´¥:`, error);
                        
                        if (attempt < retries) {
                            // å¦‚æœå¤±è´¥ï¼Œå°è¯•åˆ‡æ¢RPCèŠ‚ç‚¹
                            this.setStatus(`äº¤æ˜“å¤±è´¥ï¼Œåˆ‡æ¢RPCèŠ‚ç‚¹é‡è¯•...`, 'warning');
                            
                            this.state.currentRpcIndex = (this.state.currentRpcIndex + 1) % this.rpcNodes.length;
                            const newRpc = this.rpcNodes[this.state.currentRpcIndex];
                            this.setNetwork(`åˆ‡æ¢åˆ°èŠ‚ç‚¹: ${newRpc}`, 'warning');
                            
                            // ç­‰å¾…1ç§’åé‡è¯•
                            await new Promise(resolve => setTimeout(resolve, 1000));
                        } else {
                            throw error;
                        }
                    }
                }
            }

            async startRealBlockchainGame() {
                if (!this.state.wallet.connected) {
                    this.setStatus('è¯·å…ˆè¿æ¥é’±åŒ…è¿›è¡ŒçœŸå®åŒºå—é“¾æ¸¸æˆ', 'warning');
                    return;
                }

                if (this.state.isPlaying) return;

                try {
                    this.state.isPlaying = true;
                    this.updateUI(true);

                    const { selectedToken } = this.state;
                    const tokenContract = selectedToken === 'MAO' ? this.state.contracts.mao : this.state.contracts.pi;
                    const amount = ethers.utils.parseEther(selectedToken === 'MAO' ? '100' : '1000');
                    
                    // çœŸå®ä½™é¢æ£€æŸ¥
                    this.setStatus('æ£€æŸ¥çœŸå®ä»£å¸ä½™é¢...', 'loading');
                    const balance = await tokenContract.balanceOf(this.state.wallet.address);
                    if (balance.lt(amount)) {
                        throw new Error(`çœŸå®ä½™é¢ä¸è¶³ï¼éœ€è¦ ${selectedToken === 'MAO' ? '100' : '1000'} ${selectedToken} ä»£å¸`);
                    }

                    // çœŸå®æˆæƒæ£€æŸ¥
                    this.setStatus('æ£€æŸ¥æ™ºèƒ½åˆçº¦æˆæƒ...', 'loading');
                    const allowance = await tokenContract.allowance(this.state.wallet.address, this.addresses.WHEEL_GAME);
                    if (allowance.lt(amount)) {
                        this.setStatus('æˆæƒæ™ºèƒ½åˆçº¦è®¿é—®ä»£å¸...', 'loading');
                        
                        const approveTx = await this.executeContractCall(async () => {
                            return await tokenContract.approve(this.addresses.WHEEL_GAME, ethers.constants.MaxUint256);
                        });
                        
                        this.setStatus('ç­‰å¾…æˆæƒäº¤æ˜“ç¡®è®¤...', 'loading');
                        await approveTx.wait(3);
                        this.setStatus('æˆæƒæˆåŠŸï¼Œå‡†å¤‡æ¸¸æˆ', 'success');
                    }

                    this.setStatus('å¯åŠ¨çœŸå®åŒºå—é“¾è½¬ç›˜...', 'loading');
                    this.startSpin();
                    
                    // ğŸ”— å¤šé‡ä¿æŠ¤çš„çœŸå®åŒºå—é“¾è°ƒç”¨
                    const gasOptions = {
                        gasLimit: selectedToken === 'MAO' ? 1000000 : 1200000, // å¢åŠ Gasé™åˆ¶
                        gasPrice: ethers.utils.parseUnits('25', 'gwei') // å¢åŠ Gasä»·æ ¼ç¡®ä¿æˆåŠŸ
                    };
                    
                    const gameTx = await this.executeContractCall(async () => {
                        if (selectedToken === 'MAO') {
                            return await this.state.contracts.wheelGame.playMAOGame(gasOptions);
                        } else {
                            return await this.state.contracts.wheelGame.playPIGame(gasOptions);
                        }
                    });

                    this.setStatus('çœŸå®åŒºå—é“¾æŒ–çŸ¿ç¡®è®¤ä¸­...è¯·ç­‰å¾…', 'loading');
                    const receipt = await gameTx.wait(6); // ç­‰å¾…6ä¸ªç¡®è®¤æé«˜å¯é æ€§

                    // ğŸ”— çœŸå®ç»“æœè§£æ - å¤šé‡æœºåˆ¶ç¡®ä¿æˆåŠŸ
                    let result = null;
                    
                    // æ–¹æ³•1ï¼šäº‹ä»¶è§£æ
                    try {
                        if (receipt.events && receipt.events.length > 0) {
                            const gameEvent = receipt.events.find(e => e.event === 'GamePlayed');
                            if (gameEvent && gameEvent.args) {
                                const { rewardAmount, rewardLevel } = gameEvent.args;
                                result = {
                                    isWin: rewardAmount.gt(0),
                                    amount: ethers.utils.formatEther(rewardAmount),
                                    level: rewardLevel.toString()
                                };
                            }
                        }
                    } catch (eventError) {
                        console.log('äº‹ä»¶è§£æå¤±è´¥ï¼Œå°è¯•å…¶ä»–æ–¹æ³•');
                    }
                    
                    // æ–¹æ³•2ï¼šæ—¥å¿—è§£æ
                    if (!result && receipt.logs && receipt.logs.length > 0) {
                        try {
                            for (const log of receipt.logs) {
                                try {
                                    const parsedLog = this.state.contracts.wheelGame.interface.parseLog(log);
                                    if (parsedLog.name === 'GamePlayed') {
                                        const { rewardAmount, rewardLevel } = parsedLog.args;
                                        result = {
                                            isWin: rewardAmount.gt(0),
                                            amount: ethers.utils.formatEther(rewardAmount),
                                            level: rewardLevel.toString()
                                        };
                                        break;
                                    }
                                } catch (parseError) {
                                    continue;
                                }
                            }
                        } catch (logError) {
                            console.log('æ—¥å¿—è§£æå¤±è´¥ï¼Œå°è¯•å†å²æŸ¥è¯¢');
                        }
                    }
                    
                    // æ–¹æ³•3ï¼šå†å²æŸ¥è¯¢
                    if (!result) {
                        try {
                            this.setStatus('æŸ¥è¯¢çœŸå®æ¸¸æˆè®°å½•...', 'loading');
                            await new Promise(resolve => setTimeout(resolve, 3000)); // ç­‰å¾…3ç§’è®©åŒºå—é“¾æ›´æ–°
                            
                            const newHistory = await this.state.contracts.wheelGame.getPlayerHistory(this.state.wallet.address);
                            if (newHistory.length > 0) {
                                const lastGame = newHistory[newHistory.length - 1];
                                const timeDiff = Date.now() / 1000 - lastGame.timestamp.toNumber();
                                if (timeDiff < 600) { // 10åˆ†é’Ÿå†…çš„æ¸¸æˆ
                                    result = {
                                        isWin: lastGame.rewardAmount.gt(0),
                                        amount: ethers.utils.formatEther(lastGame.rewardAmount),
                                        level: lastGame.rewardLevel.toString()
                                    };
                                }
                            }
                        } catch (historyError) {
                            console.error('å†å²æŸ¥è¯¢å¤±è´¥:', historyError);
                        }
                    }
                    
                    // å¦‚æœä»ç„¶æ— æ³•è§£æç»“æœï¼Œè¿™æ˜¯çœŸå®çš„åŒºå—é“¾é”™è¯¯
                    if (!result) {
                        throw new Error('æ— æ³•è§£æçœŸå®åŒºå—é“¾æ¸¸æˆç»“æœï¼Œäº¤æ˜“å¯èƒ½ä»åœ¨å¤„ç†ä¸­ï¼Œè¯·ç¨åæŸ¥çœ‹é’±åŒ…ä½™é¢å˜åŒ–');
                    }

                    // æ˜¾ç¤ºçœŸå®ç»“æœ
                    setTimeout(() => {
                        this.showResult(result, gameTx.hash);
                        this.loadStats(); // é‡æ–°åŠ è½½çœŸå®ç»Ÿè®¡
                    }, 2000);

                } catch (error) {
                    console.error('çœŸå®åŒºå—é“¾æ¸¸æˆé”™è¯¯:', error);
                    
                    let errorMsg = error.message;
                    if (errorMsg.includes('insufficient funds')) {
                        errorMsg = 'ä½™é¢ä¸è¶³ï¼Œè¯·å……å€¼è¶³å¤Ÿçš„ä»£å¸å’ŒALV';
                    } else if (errorMsg.includes('user rejected')) {
                        errorMsg = 'ç”¨æˆ·å–æ¶ˆäº†äº¤æ˜“';
                    } else if (errorMsg.includes('gas')) {
                        errorMsg = 'Gasè´¹ç”¨ä¸è¶³ï¼Œè¯·å¢åŠ Gasè´¹ç”¨';
                    } else if (errorMsg.includes('network') || errorMsg.includes('RPC')) {
                        errorMsg = 'RPCç½‘ç»œè¿æ¥é—®é¢˜ï¼Œå·²è‡ªåŠ¨å°è¯•å¤šä¸ªèŠ‚ç‚¹';
                    } else if (errorMsg.includes('CALL_EXCEPTION')) {
                        errorMsg = 'æ™ºèƒ½åˆçº¦è°ƒç”¨å¤±è´¥ï¼Œå¯èƒ½æ˜¯ç½‘ç»œæ‹¥å µï¼Œè¯·ç¨åé‡è¯•';
                    }

                    this.setStatus(`çœŸå®æ¸¸æˆé”™è¯¯: ${errorMsg}`, 'error');
                    this.stopSpin();
                    this.state.isPlaying = false;
                    this.updateUI(false);
                }
            }

            init() {
                document.addEventListener('DOMContentLoaded', () => {
                    this.setupEvents();
                    this.updateTokens();
                    this.updateStats();
                    this.setupNetwork();
                });

                if (window.ethereum) {
                    window.ethereum.on('accountsChanged', (accounts) => {
                        if (accounts.length === 0) {
                            this.state.wallet.connected = false;
                            this.updateWallet();
                            this.setStatus('é’±åŒ…å·²æ–­å¼€', 'warning');
                        } else {
                            this.connectWallet();
                        }
                    });

                    window.ethereum.on('chainChanged', () => {
                        this.setStatus('ç½‘ç»œå·²åˆ‡æ¢ï¼Œé‡æ–°è¿æ¥...', 'info');
                        setTimeout(() => window.location.reload(), 1000);
                    });
                }
            }

            setupEvents() {
                document.getElementById('connectBtn')?.addEventListener('click', () => this.connectWallet());

                document.getElementById('selectMao')?.addEventListener('click', () => {
                    this.state.selectedToken = 'MAO';
                    this.updateTokens();
                    this.setStatus('MAO çœŸå®ä»£å¸æ¨¡å¼', 'info');
                });
                
                document.getElementById('selectPi')?.addEventListener('click', () => {
                    this.state.selectedToken = 'PI';
                    this.updateTokens();
                    this.setStatus('PI çœŸå®ä»£å¸æ¨¡å¼', 'info');
                });

                document.getElementById('spinBtn')?.addEventListener('click', () => this.startRealBlockchainGame());

                document.getElementById('closeModal')?.addEventListener('click', () => {
                    document.getElementById('resultModal')?.classList.add('hidden');
                });
            }
        }

        // ğŸš€ å¯åŠ¨å¤šèŠ‚ç‚¹çœŸå®åŒºå—é“¾æ¸¸æˆå¼•æ“ v8.5
        const multiRpcGame = new MultiRpcBlockchainGameEngine();
        multiRpcGame.init();
    </script>
</body>
</html>
