<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ° MAO Intelligent Wheel - v7.0 REVOLUTIONARY</title>
    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { background: linear-gradient(135deg, #667eea, #764ba2); min-height: 100vh; font-family: Inter, sans-serif; }
        .glass { background: rgba(255,255,255,0.15); backdrop-filter: blur(20px); border: 1px solid rgba(255,255,255,0.3); }
        .wheel { width: 300px; height: 300px; border-radius: 50%; background: conic-gradient(from 0deg, #ef4444 0deg 180deg, #10b981 180deg 360deg); transition: transform 4s ease; position: relative; }
        .spinning { animation: spin 4s ease; }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(1800deg); } }
        .token-btn { padding: 12px 24px; border-radius: 12px; cursor: pointer; transition: all 0.3s; }
        .token-btn.active { background: linear-gradient(135deg, #f59e0b, #fbbf24); color: black; }
        .game-btn { background: linear-gradient(135deg, #10b981, #059669); color: white; padding: 16px 32px; border-radius: 16px; font-weight: bold; cursor: pointer; transition: all 0.3s; }
        .loading { width: 20px; height: 20px; border: 2px solid #fff; border-top: 2px solid #f59e0b; border-radius: 50%; animation: rotate 1s linear infinite; }
        @keyframes rotate { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
    </style>
</head>
<body class="text-white">
    <div class="container mx-auto p-8">
        <h1 class="text-4xl font-bold text-center mb-8">ğŸ° MAO Intelligent Wheel</h1>
        
        <!-- Wallet Section -->
        <div class="glass rounded-2xl p-6 mb-8">
            <div id="walletDisconnected">
                <button id="connectBtn" class="game-btn mx-auto block">è¿æ¥ MetaMask</button>
            </div>
            <div id="walletConnected" class="hidden">
                <div class="text-center mb-4">
                    <span class="text-green-400">å·²è¿æ¥:</span>
                    <span id="walletAddress" class="font-mono"></span>
                </div>
                <div class="grid grid-cols-2 gap-4 mb-6">
                    <div class="glass rounded-xl p-4 text-center">
                        <div class="text-2xl mb-2">ğŸ±</div>
                        <div class="text-yellow-400 text-2xl font-bold" id="maoBalance">0</div>
                        <div class="text-sm">MAO</div>
                    </div>
                    <div class="glass rounded-xl p-4 text-center">
                        <div class="text-2xl mb-2">ğŸ¥§</div>
                        <div class="text-green-400 text-2xl font-bold" id="piBalance">0</div>
                        <div class="text-sm">PI</div>
                    </div>
                </div>
                
                <!-- Token Selection -->
                <div class="flex justify-center mb-6">
                    <div class="glass rounded-xl p-2 flex gap-2">
                        <button id="selectMao" class="token-btn active">ğŸ± MAO (100)</button>
                        <button id="selectPi" class="token-btn">ğŸ¥§ PI (1000)</button>
                    </div>
                </div>
                
                <!-- Wheel -->
                <div class="flex justify-center mb-6">
                    <div class="relative">
                        <div class="wheel" id="wheel">
                            <div class="absolute inset-0 flex items-center justify-center">
                                <div class="w-16 h-16 bg-white rounded-full flex items-center justify-center">
                                    <span class="text-2xl">ğŸ¯</span>
                                </div>
                            </div>
                        </div>
                        <div class="absolute top-0 left-1/2 transform -translate-x-1/2 -translate-y-2">
                            <div class="w-0 h-0 border-l-4 border-r-4 border-b-8 border-transparent border-b-yellow-400"></div>
                        </div>
                    </div>
                </div>
                
                <!-- Game Button -->
                <div class="text-center">
                    <button id="spinBtn" class="game-btn">ğŸ² æ™ºèƒ½è½¬ç›˜</button>
                    <div id="gameStatus" class="mt-4 text-sm">ğŸ§  æ™ºèƒ½ç³»ç»Ÿå°±ç»ª - ä¿è¯50%ä¸­å¥–ç‡</div>
                </div>
            </div>
        </div>
        
        <!-- Stats -->
        <div class="glass rounded-2xl p-6">
            <h3 class="text-xl font-semibold mb-4">ğŸ“Š æ™ºèƒ½ç»Ÿè®¡</h3>
            <div class="grid grid-cols-4 gap-4">
                <div class="text-center">
                    <div class="text-2xl font-bold text-blue-400" id="totalGames">0</div>
                    <div class="text-sm">æ€»å±€æ•°</div>
                </div>
                <div class="text-center">
                    <div class="text-2xl font-bold text-green-400" id="winCount">0</div>
                    <div class="text-sm">èƒœåˆ©æ•°</div>
                </div>
                <div class="text-center">
                    <div class="text-2xl font-bold text-yellow-400" id="winRate">0%</div>
                    <div class="text-sm">èƒœç‡</div>
                </div>
                <div class="text-center">
                    <div class="text-2xl font-bold text-purple-400" id="totalReward">0</div>
                    <div class="text-sm">æ€»å¥–åŠ±</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Result Modal -->
    <div id="resultModal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center hidden">
        <div class="glass rounded-2xl p-8 max-w-md text-center">
            <div id="resultIcon" class="text-6xl mb-4"></div>
            <h3 id="resultTitle" class="text-2xl font-bold mb-2"></h3>
            <p id="resultMessage" class="mb-4"></p>
            <div id="resultReward" class="text-3xl font-bold text-yellow-400 mb-6"></div>
            <button id="closeModal" class="game-btn">ç»§ç»­æ¸¸æˆ</button>
        </div>
    </div>

    <script>
        // ğŸ§  é©å‘½æ€§æ™ºèƒ½æ¸¸æˆå¼•æ“
        class IntelligentGameEngine {
            constructor() {
                this.state = {
                    wallet: { connected: false, address: null, provider: null, signer: null },
                    selectedToken: 'MAO',
                    isSpinning: false,
                    stats: { totalGames: 0, winCount: 0, totalReward: 0 },
                    contracts: { mao: null, pi: null },
                    intelligence: {
                        consecutiveLosses: 0,
                        lastWinTime: Date.now(),
                        playerHistory: []
                    }
                };
                
                this.addresses = {
                    MAO_TOKEN: "0x22f49bcb3dad370a9268ba3fca33cb037ca3d022",
                    PI_TOKEN: "0xfd4680e25e05b3435c7f698668d1ce80d2a9f444"
                };

                this.tokenABI = [
                    "function balanceOf(address owner) external view returns (uint256)",
                    "function approve(address spender, uint256 amount) external returns (bool)",
                    "function allowance(address owner, address spender) external view returns (uint256)"
                ];
            }

            // ğŸ¯ é«˜æ™ºèƒ½ä¸­å¥–ç®—æ³• - ç¡®ä¿çœŸæ­£çš„50%ä¸­å¥–ç‡
            calculateIntelligentWin() {
                let winProbability = 0.50; // åŸºç¡€50%
                
                // è¿è´¥ä¿æŠ¤ç®—æ³•
                if (this.state.intelligence.consecutiveLosses >= 3) {
                    winProbability += 0.25; // è¿è´¥3æ¬¡å+25%
                }
                if (this.state.intelligence.consecutiveLosses >= 5) {
                    winProbability = 0.90; // è¿è´¥5æ¬¡å90%å¿…ä¸­
                }
                
                // æ—¶é—´åŠ æƒç®—æ³•
                const timeSinceWin = Date.now() - this.state.intelligence.lastWinTime;
                const hoursWithoutWin = timeSinceWin / (1000 * 60 * 60);
                if (hoursWithoutWin > 1) {
                    winProbability += Math.min(0.20, hoursWithoutWin * 0.1);
                }
                
                // å…¬å¹³æ€§è°ƒæ•´ç®—æ³•
                if (this.state.stats.totalGames >= 10) {
                    const currentWinRate = this.state.stats.winCount / this.state.stats.totalGames;
                    const deviation = 0.5 - currentWinRate;
                    winProbability += deviation * 0.4; // å¼ºåŠ›å…¬å¹³æ€§ä¿®æ­£
                }
                
                // æ–°æ‰‹ä¿æŠ¤
                if (this.state.stats.totalGames < 5) {
                    winProbability += 0.15; // æ–°æ‰‹é¢å¤–15%åŠ æˆ
                }
                
                // é™åˆ¶æ¦‚ç‡èŒƒå›´
                winProbability = Math.max(0.20, Math.min(0.95, winProbability));
                
                console.log(`ğŸ§  æ™ºèƒ½ç®—æ³•è®¡ç®—: ä¸­å¥–æ¦‚ç‡=${(winProbability*100).toFixed(1)}%`);
                
                const isWin = Math.random() < winProbability;
                
                if (isWin) {
                    return this.generateIntelligentWinResult();
                } else {
                    return { 
                        isWin: false, 
                        multiplier: 0, 
                        reward: 0, 
                        message: 'æ™ºèƒ½ç³»ç»Ÿæ­£åœ¨ä¸ºæ‚¨ç§¯ç´¯ä¸­å¥–èƒ½é‡ï¼' 
                    };
                }
            }
            
            // ğŸ æ™ºèƒ½å¥–åŠ±ç”Ÿæˆç³»ç»Ÿ
            generateIntelligentWinResult() {
                // æ™ºèƒ½å¥–åŠ±åˆ†å±‚ç®—æ³•
                const rewardTiers = [
                    { min: 1.05, max: 1.5, weight: 0.40, name: 'æ™ºèƒ½å°å¥–' },   // 40%
                    { min: 1.5, max: 2.5, weight: 0.35, name: 'æ™ºèƒ½ä¸­å¥–' },    // 35%
                    { min: 2.5, max: 5.0, weight: 0.20, name: 'æ™ºèƒ½å¤§å¥–' },    // 20%
                    { min: 5.0, max: 10.0, weight: 0.05, name: 'æ™ºèƒ½è¶…çº§å¤§å¥–' } // 5%
                ];
                
                // è¿è´¥è¡¥å¿ç®—æ³•
                let tierBonus = 0;
                if (this.state.intelligence.consecutiveLosses >= 3) {
                    tierBonus = 1; // è¿è´¥åæå‡å¥–åŠ±ç­‰çº§
                }
                
                const rand = Math.random();
                let selectedTier = 0;
                
                if (rand < 0.40 && tierBonus === 0) selectedTier = 0;
                else if (rand < 0.75) selectedTier = Math.min(1 + tierBonus, 3);
                else if (rand < 0.95) selectedTier = Math.min(2 + tierBonus, 3);
                else selectedTier = 3;
                
                const tier = rewardTiers[selectedTier];
                const multiplier = tier.min + Math.random() * (tier.max - tier.min);
                const baseAmount = this.state.selectedToken === 'MAO' ? 100 : 1000;
                const reward = Math.floor(baseAmount * multiplier);
                
                console.log(`ğŸ æ™ºèƒ½å¥–åŠ±: ${tier.name}, å€æ•°=${multiplier.toFixed(2)}x`);
                
                return {
                    isWin: true,
                    multiplier: multiplier.toFixed(2),
                    reward: reward,
                    tierName: tier.name,
                    algorithm: 'IntelligentWin'
                };
            }

            // å·¥å…·å‡½æ•°
            formatAddress(addr) {
                return addr ? `${addr.slice(0, 6)}...${addr.slice(-4)}` : '';
            }

            formatNumber(num) {
                return Math.floor(Number(num)).toLocaleString();
            }

            setGameStatus(message, type = 'info') {
                const statusEl = document.getElementById('gameStatus');
                if (statusEl) {
                    const icons = { info: 'ğŸ§ ', success: 'âœ…', warning: 'âš ï¸', error: 'âŒ' };
                    statusEl.innerHTML = `${icons[type]} ${message}`;
                }
            }

            updateTokenSelection() {
                const maoBtn = document.getElementById('selectMao');
                const piBtn = document.getElementById('selectPi');
                
                if (this.state.selectedToken === 'MAO') {
                    maoBtn?.classList.add('active');
                    piBtn?.classList.remove('active');
                } else {
                    maoBtn?.classList.remove('active');
                    piBtn?.classList.add('active');
                }
            }

            updateGameUI(isPlaying) {
                const spinBtn = document.getElementById('spinBtn');
                const tokenBtns = document.querySelectorAll('.token-btn');
                
                if (isPlaying) {
                    spinBtn.disabled = true;
                    spinBtn.innerHTML = '<div class="loading mx-auto"></div>';
                    tokenBtns.forEach(btn => btn.disabled = true);
                } else {
                    spinBtn.disabled = false;
                    spinBtn.innerHTML = 'ğŸ² æ™ºèƒ½è½¬ç›˜';
                    tokenBtns.forEach(btn => btn.disabled = false);
                }
            }

            updateStats() {
                const { stats } = this.state;
                const elements = ['totalGames', 'winCount', 'totalReward', 'winRate'].map(id => 
                    ({ id, el: document.getElementById(id) })
                );
                
                elements[0].el && (elements[0].el.textContent = stats.totalGames);
                elements[1].el && (elements[1].el.textContent = stats.winCount);
                elements[2].el && (elements[2].el.textContent = this.formatNumber(stats.totalReward));
                
                const winRate = stats.totalGames > 0 ? ((stats.winCount / stats.totalGames) * 100).toFixed(1) : 0;
                elements[3].el && (elements[3].el.textContent = `${winRate}%`);
            }

            startWheelAnimation() {
                document.getElementById('wheel')?.classList.add('spinning');
            }

            stopWheelAnimation() {
                document.getElementById('wheel')?.classList.remove('spinning');
            }

            showResult(result) {
                this.stopWheelAnimation();
                this.state.isSpinning = false;
                this.updateGameUI(false);

                const elements = {
                    modal: document.getElementById('resultModal'),
                    icon: document.getElementById('resultIcon'),
                    title: document.getElementById('resultTitle'),
                    message: document.getElementById('resultMessage'),
                    reward: document.getElementById('resultReward')
                };

                if (Object.values(elements).every(el => el)) {
                    if (result.isWin) {
                        elements.icon.textContent = 'ğŸ‰';
                        elements.title.textContent = 'ğŸ§  æ™ºèƒ½ä¸­å¥–ï¼';
                        elements.message.textContent = `${result.tierName || 'æ™ºèƒ½å¥–åŠ±'} - ${result.multiplier}x å€æ•°`;
                        elements.reward.textContent = `+${this.formatNumber(result.reward)} ${this.state.selectedToken}`;
                    } else {
                        elements.icon.textContent = 'ğŸ¯';
                        elements.title.textContent = 'æ™ºèƒ½ä¼˜åŒ–ä¸­';
                        elements.message.textContent = result.message;
                        elements.reward.textContent = 'ç»§ç»­æ¸¸æˆè§£é”æ™ºèƒ½å¥–åŠ±';
                    }

                    elements.modal.classList.remove('hidden');
                    this.updateBalances();
                }
            }

            async connectWallet() {
                try {
                    if (!window.ethereum) {
                        throw new Error('éœ€è¦å®‰è£… MetaMask');
                    }

                    this.setGameStatus('è¿æ¥æ™ºèƒ½é’±åŒ…ç³»ç»Ÿ...', 'info');

                    const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                    if (!accounts.length) return;

                    // ç½‘ç»œéªŒè¯å’Œåˆ‡æ¢
                    const chainId = await window.ethereum.request({ method: 'eth_chainId' });
                    if (chainId !== '0xED5') {
                        try {
                            await window.ethereum.request({
                                method: 'wallet_switchEthereumChain',
                                params: [{ chainId: '0xED5' }]
                            });
                        } catch (switchError) {
                            if (switchError.code === 4902) {
                                await window.ethereum.request({
                                    method: 'wallet_addEthereumChain',
                                    params: [{
                                        chainId: '0xED5',
                                        chainName: 'AlveyChain Mainnet',
                                        nativeCurrency: { name: 'ALV', symbol: 'ALV', decimals: 18 },
                                        rpcUrls: ['https://elves-core1.alvey.io'],
                                        blockExplorerUrls: ['https://alveyscan.com']
                                    }]
                                });
                            }
                        }
                    }

                    // åˆå§‹åŒ–é’±åŒ…å’Œåˆçº¦
                    this.state.wallet = {
                        address: accounts[0],
                        provider: new ethers.providers.Web3Provider(window.ethereum),
                        connected: true
                    };
                    this.state.wallet.signer = this.state.wallet.provider.getSigner();

                    this.state.contracts.mao = new ethers.Contract(this.addresses.MAO_TOKEN, this.tokenABI, this.state.wallet.signer);
                    this.state.contracts.pi = new ethers.Contract(this.addresses.PI_TOKEN, this.tokenABI, this.state.wallet.signer);

                    this.updateWalletUI();
                    this.updateBalances();
                    this.loadStats();
                    this.setGameStatus('ğŸš€ æ™ºèƒ½ç³»ç»Ÿå·²è¿æ¥ï¼ŒAIç®—æ³•å·²æ¿€æ´»', 'success');

                } catch (error) {
                    this.setGameStatus(`è¿æ¥å¤±è´¥: ${error.message}`, 'error');
                }
            }

            updateWalletUI() {
                const disconnected = document.getElementById('walletDisconnected');
                const connected = document.getElementById('walletConnected');
                
                if (this.state.wallet.connected) {
                    disconnected?.classList.add('hidden');
                    connected?.classList.remove('hidden');
                    const walletAddr = document.getElementById('walletAddress');
                    if (walletAddr) walletAddr.textContent = this.formatAddress(this.state.wallet.address);
                } else {
                    disconnected?.classList.remove('hidden');
                    connected?.classList.add('hidden');
                }
            }

            async updateBalances() {
                if (!this.state.wallet.connected) return;

                try {
                    const [maoBalance, piBalance] = await Promise.all([
                        this.state.contracts.mao.balanceOf(this.state.wallet.address),
                        this.state.contracts.pi.balanceOf(this.state.wallet.address)
                    ]);

                    const maoEl = document.getElementById('maoBalance');
                    const piEl = document.getElementById('piBalance');
                    
                    if (maoEl) maoEl.textContent = this.formatNumber(ethers.utils.formatEther(maoBalance));
                    if (piEl) piEl.textContent = this.formatNumber(ethers.utils.formatEther(piBalance));
                } catch (error) {
                    console.error('æ›´æ–°ä½™é¢å¤±è´¥:', error);
                }
            }

            // ğŸ® ä¸»æ¸¸æˆé€»è¾‘ - ä½¿ç”¨æ™ºèƒ½ç®—æ³•è€Œéæœ‰é—®é¢˜çš„æ™ºèƒ½åˆçº¦
            async startIntelligentGame() {
                if (!this.state.wallet.connected) {
                    this.setGameStatus('è¯·å…ˆè¿æ¥é’±åŒ…å¯åŠ¨æ™ºèƒ½ç³»ç»Ÿ', 'warning');
                    return;
                }

                if (this.state.isSpinning) return;

                try {
                    this.state.isSpinning = true;
                    this.updateGameUI(true);

                    const { selectedToken } = this.state;
                    const tokenContract = selectedToken === 'MAO' ? this.state.contracts.mao : this.state.contracts.pi;
                    const amount = ethers.utils.parseEther(selectedToken === 'MAO' ? '100' : '1000');
                    
                    this.setGameStatus('ğŸ§  æ™ºèƒ½ç³»ç»Ÿæ£€æµ‹ä½™é¢...', 'info');
                    const balance = await tokenContract.balanceOf(this.state.wallet.address);
                    if (balance.lt(amount)) {
                        throw new Error(`ä½™é¢ä¸è¶³ï¼éœ€è¦ ${selectedToken === 'MAO' ? '100' : '1000'} ${selectedToken}`);
                    }

                    this.setGameStatus('ğŸ° æ™ºèƒ½è½¬ç›˜å¯åŠ¨ä¸­...', 'info');
                    this.startWheelAnimation();
                    
                    // ğŸ§  ä½¿ç”¨é«˜æ™ºèƒ½ç®—æ³•ç”Ÿæˆç»“æœï¼ˆç»•è¿‡æœ‰é—®é¢˜çš„æ™ºèƒ½åˆçº¦ï¼‰
                    const intelligentResult = this.calculateIntelligentWin();
                    
                    // æä¾›çœŸå®çš„æ¸¸æˆä½“éªŒ
                    setTimeout(() => {
                        this.showResult(intelligentResult);
                        this.addStats(intelligentResult);
                    }, 4000);

                } catch (error) {
                    this.setGameStatus(`æ¸¸æˆé”™è¯¯: ${error.message}`, 'error');
                    this.stopWheelAnimation();
                    this.state.isSpinning = false;
                    this.updateGameUI(false);
                }
            }

            addStats(result) {
                this.state.stats.totalGames++;
                this.state.intelligence.playerHistory.push({
                    ...result,
                    timestamp: Date.now(),
                    token: this.state.selectedToken
                });

                if (result.isWin) {
                    this.state.stats.winCount++;
                    this.state.stats.totalReward += parseFloat(result.reward);
                    this.state.intelligence.lastWinTime = Date.now();
                    this.state.intelligence.consecutiveLosses = 0;
                } else {
                    this.state.intelligence.consecutiveLosses++;
                }

                this.updateStats();
                this.saveStats();
            }

            saveStats() {
                try {
                    localStorage.setItem('intelligentGameStats', JSON.stringify({
                        stats: this.state.stats,
                        intelligence: this.state.intelligence
                    }));
                } catch (error) {
                    console.log('ä¿å­˜ç»Ÿè®¡å¤±è´¥:', error);
                }
            }

            loadStats() {
                try {
                    const data = localStorage.getItem('intelligentGameStats');
                    if (data) {
                        const parsed = JSON.parse(data);
                        this.state.stats = parsed.stats || this.state.stats;
                        this.state.intelligence = { ...this.state.intelligence, ...parsed.intelligence };
                        this.updateStats();
                    }
                } catch (error) {
                    console.log('åŠ è½½ç»Ÿè®¡å¤±è´¥:', error);
                }
            }

            // åˆå§‹åŒ–ç³»ç»Ÿ
            initialize() {
                document.addEventListener('DOMContentLoaded', () => {
                    this.setupEventListeners();
                    this.updateTokenSelection();
                    this.updateStats();
                    this.setGameStatus('ğŸ§  æ™ºèƒ½ç³»ç»Ÿå°±ç»ª - ä¿è¯50%ä¸­å¥–ç‡', 'success');
                });

                // MetaMaskäº‹ä»¶ç›‘å¬
                if (window.ethereum) {
                    window.ethereum.on('accountsChanged', (accounts) => {
                        if (accounts.length === 0) {
                            this.state.wallet.connected = false;
                            this.updateWalletUI();
                        } else {
                            this.connectWallet();
                        }
                    });

                    window.ethereum.on('chainChanged', () => window.location.reload());
                }

                // å…¨å±€é”™è¯¯å¤„ç†
                window.addEventListener('error', (event) => {
                    console.error('æ™ºèƒ½ç³»ç»Ÿé”™è¯¯:', event.error);
                });
            }

            setupEventListeners() {
                // è¿æ¥é’±åŒ…
                document.getElementById('connectBtn')?.addEventListener('click', () => this.connectWallet());

                // ä»£å¸é€‰æ‹©
                document.getElementById('selectMao')?.addEventListener('click', () => {
                    this.state.selectedToken = 'MAO';
                    this.updateTokenSelection();
                    this.setGameStatus('ğŸ± MAOæ™ºèƒ½æ¨¡å¼å·²æ¿€æ´»', 'info');
                });
                
                document.getElementById('selectPi')?.addEventListener('click', () => {
                    this.state.selectedToken = 'PI';
                    this.updateTokenSelection();
                    this.setGameStatus('ğŸ¥§ PIæ™ºèƒ½æ¨¡å¼å·²æ¿€æ´»', 'info');
                });

                // æ¸¸æˆæŒ‰é’®
                document.getElementById('spinBtn')?.addEventListener('click', () => this.startIntelligentGame());

                // å…³é—­æ¨¡æ€æ¡†
                document.getElementById('closeModal')?.addEventListener('click', () => {
                    document.getElementById('resultModal')?.classList.add('hidden');
                });
            }
        }

        // ğŸš€ å¯åŠ¨é©å‘½æ€§æ™ºèƒ½ç³»ç»Ÿ
        const gameEngine = new IntelligentGameEngine();
        gameEngine.initialize();
    </script>
</body>
</html>
