<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ° MAO Real Blockchain Wheel - FIXED FINAL v8.7</title>
    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { background: linear-gradient(135deg, #667eea, #764ba2); min-height: 100vh; font-family: Inter, sans-serif; }
        .glass { background: rgba(255,255,255,0.15); backdrop-filter: blur(20px); border: 1px solid rgba(255,255,255,0.3); }
        .wheel { width: 300px; height: 300px; border-radius: 50%; background: conic-gradient(from 0deg, #ef4444 0deg 180deg, #10b981 180deg 360deg); transition: transform 4s ease; position: relative; }
        .spinning { animation: spin 4s ease; }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(1800deg); } }
        .token-btn { padding: 12px 24px; border-radius: 12px; cursor: pointer; transition: all 0.3s; }
        .token-btn.active { background: linear-gradient(135deg, #f59e0b, #fbbf24); color: black; }
        .game-btn { background: linear-gradient(135deg, #10b981, #059669); color: white; padding: 16px 32px; border-radius: 16px; font-weight: bold; cursor: pointer; transition: all 0.3s; }
        .loading { width: 20px; height: 20px; border: 2px solid #fff; border-top: 2px solid #f59e0b; border-radius: 50%; animation: rotate 1s linear infinite; }
        @keyframes rotate { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
    </style>
</head>
<body class="text-white">
    <div class="container mx-auto p-8">
        <h1 class="text-4xl font-bold text-center mb-8">ğŸ° MAO Real Blockchain Game - FIXED FINAL v8.7</h1>
        
        <!-- Status Bar -->
        <div class="glass rounded-2xl p-4 mb-6">
            <div class="flex items-center justify-center">
                <span id="networkStatus" class="text-sm">ğŸ”— åˆå§‹åŒ–æ™ºèƒ½åŒºå—é“¾è¿æ¥...</span>
            </div>
        </div>
        
        <!-- Wallet Section -->
        <div class="glass rounded-2xl p-6 mb-8">
            <div id="walletDisconnected">
                <button id="connectBtn" class="game-btn mx-auto block">è¿æ¥ MetaMask é’±åŒ…</button>
            </div>
            <div id="walletConnected" class="hidden">
                <div class="text-center mb-4">
                    <span class="text-green-400">é’±åŒ…å·²è¿æ¥:</span>
                    <span id="walletAddress" class="font-mono"></span>
                </div>
                <div class="grid grid-cols-2 gap-4 mb-6">
                    <div class="glass rounded-xl p-4 text-center">
                        <div class="text-2xl mb-2">ğŸ±</div>
                        <div class="text-yellow-400 text-2xl font-bold" id="maoBalance">0</div>
                        <div class="text-sm">MAO</div>
                    </div>
                    <div class="glass rounded-xl p-4 text-center">
                        <div class="text-2xl mb-2">ğŸ¥§</div>
                        <div class="text-green-400 text-2xl font-bold" id="piBalance">0</div>
                        <div class="text-sm">PI</div>
                    </div>
                </div>
                
                <!-- Token Selection -->
                <div class="flex justify-center mb-6">
                    <div class="glass rounded-xl p-2 flex gap-2">
                        <button id="selectMao" class="token-btn active">ğŸ± MAO (100)</button>
                        <button id="selectPi" class="token-btn">ğŸ¥§ PI (1000)</button>
                    </div>
                </div>
                
                <!-- Wheel -->
                <div class="flex justify-center mb-6">
                    <div class="relative">
                        <div class="wheel" id="wheel">
                            <div class="absolute inset-0 flex items-center justify-center">
                                <div class="w-16 h-16 bg-white rounded-full flex items-center justify-center">
                                    <span class="text-2xl">ğŸ¯</span>
                                </div>
                            </div>
                        </div>
                        <div class="absolute top-0 left-1/2 transform -translate-x-1/2 -translate-y-2">
                            <div class="w-0 h-0 border-l-4 border-r-4 border-b-8 border-transparent border-b-yellow-400"></div>
                        </div>
                    </div>
                </div>
                
                <!-- Game Button -->
                <div class="text-center">
                    <button id="spinBtn" class="game-btn">ğŸ² çœŸå®åŒºå—é“¾è½¬ç›˜</button>
                    <div id="gameStatus" class="mt-4 text-sm">âœ… æ™ºèƒ½è¿æ¥ç³»ç»Ÿå·²å°±ç»ª</div>
                </div>
            </div>
        </div>
        
        <!-- Stats -->
        <div class="glass rounded-2xl p-6">
            <h3 class="text-xl font-semibold mb-4">ğŸ“Š çœŸå®åŒºå—é“¾ç»Ÿè®¡</h3>
            <div class="grid grid-cols-4 gap-4">
                <div class="text-center">
                    <div class="text-2xl font-bold text-blue-400" id="totalGames">0</div>
                    <div class="text-sm">æ€»å±€æ•°</div>
                </div>
                <div class="text-center">
                    <div class="text-2xl font-bold text-green-400" id="winCount">0</div>
                    <div class="text-sm">èƒœåˆ©æ•°</div>
                </div>
                <div class="text-center">
                    <div class="text-2xl font-bold text-yellow-400" id="winRate">0%</div>
                    <div class="text-sm">èƒœç‡</div>
                </div>
                <div class="text-center">
                    <div class="text-2xl font-bold text-purple-400" id="totalReward">0</div>
                    <div class="text-sm">æ€»å¥–åŠ±</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Result Modal -->
    <div id="resultModal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center hidden">
        <div class="glass rounded-2xl p-8 max-w-md text-center">
            <div id="resultIcon" class="text-6xl mb-4"></div>
            <h3 id="resultTitle" class="text-2xl font-bold mb-2"></h3>
            <p id="resultMessage" class="mb-4"></p>
            <div id="resultReward" class="text-3xl font-bold text-yellow-400 mb-6"></div>
            <div id="txHash" class="text-xs text-blue-300 mb-4 font-mono break-all"></div>
            <button id="closeModal" class="game-btn">ç»§ç»­æ¸¸æˆ</button>
        </div>
    </div>

    <script>
        // ğŸ¯ æœ€ç»ˆä¿®å¤ç‰ˆæœ¬ v8.7 - åº”ç”¨æ‰€æœ‰ä¿®å¤åˆ°å®é™…éƒ¨ç½²æ–‡ä»¶
        class FixedFinalBlockchainGame {
            constructor() {
                this.state = {
                    wallet: { connected: false, address: null, provider: null, signer: null },
                    selectedToken: 'MAO',
                    isPlaying: false,
                    stats: { totalGames: 0, winCount: 0, totalReward: 0 },
                    contracts: { mao: null, pi: null, wheelGame: null },
                    currentRpcIndex: 0,
                    networkReady: false
                };
                
                this.addresses = {
                    MAO_TOKEN: "0x22f49bcb3dad370a9268ba3fca33cb037ca3d022",
                    PI_TOKEN: "0xfd4680e25e05b3435c7f698668d1ce80d2a9f444",
                    WHEEL_GAME: "0x621DF9e0DE6b4e7EDC5Dc22Cd7c0F883c3F56966"
                };

                // ğŸ”§ ä¿®å¤ï¼šå¤šRPCèŠ‚ç‚¹æ”¯æŒï¼Œæ‰€æœ‰èŠ‚ç‚¹éƒ½ç»è¿‡éªŒè¯
                this.rpcNodes = [
                    'https://elves-core1.alvey.io/',  // ç»éªŒè¯å¯ç”¨
                    'https://elves-core2.alvey.io/',  // ç»éªŒè¯å¯ç”¨
                    'https://elves-core3.alvey.io/'   // ç»éªŒè¯å¯ç”¨
                ];

                this.networkConfig = {
                    chainId: '0xED5', // 3797
                    chainName: 'AlveyChain Mainnet',
                    nativeCurrency: { name: 'ALV', symbol: 'ALV', decimals: 18 },
                    rpcUrls: this.rpcNodes,
                    blockExplorerUrls: ['https://alveyscan.com']
                };

                this.tokenABI = [
                    "function balanceOf(address owner) external view returns (uint256)",
                    "function approve(address spender, uint256 amount) external returns (bool)",
                    "function allowance(address owner, address spender) external view returns (uint256)",
                    "function symbol() external view returns (string)"
                ];

                this.gameABI = [
                    "function playMAOGame() external",
                    "function playPIGame() external",
                    "function getPlayerHistory(address player) external view returns (tuple(address player, uint8 tokenType, uint256 betAmount, uint256 rewardAmount, uint8 rewardLevel, uint256 timestamp, uint256 randomSeed, bool wasProtected)[])",
                    "event GamePlayed(address indexed player, uint8 tokenType, uint256 betAmount, uint256 rewardAmount, uint8 rewardLevel, uint256 randomSeed, bool wasProtected)"
                ];
            }

            formatAddress(addr) {
                return addr ? `${addr.slice(0, 6)}...${addr.slice(-4)}` : '';
            }

            formatNumber(num) {
                return Math.floor(Number(num)).toLocaleString();
            }

            setStatus(message, type = 'info') {
                const el = document.getElementById('gameStatus');
                if (el) {
                    const icons = { info: 'ğŸ”—', success: 'âœ…', warning: 'âš ï¸', error: 'âŒ', loading: 'â³' };
                    el.innerHTML = `${icons[type]} ${message}`;
                }
            }

            setNetwork(message, type = 'info') {
                const el = document.getElementById('networkStatus');
                if (el) {
                    const icons = { info: 'ğŸ”—', success: 'ğŸŸ¢', warning: 'ğŸŸ¡', error: 'ğŸ”´' };
                    el.innerHTML = `${icons[type]} ${message}`;
                }
            }

            updateTokens() {
                const mao = document.getElementById('selectMao');
                const pi = document.getElementById('selectPi');
                
                if (this.state.selectedToken === 'MAO') {
                    mao?.classList.add('active');
                    pi?.classList.remove('active');
                } else {
                    mao?.classList.remove('active');
                    pi?.classList.add('active');
                }
            }

            updateUI(playing) {
                const btn = document.getElementById('spinBtn');
                const tokens = document.querySelectorAll('.token-btn');
                
                if (playing) {
                    btn.disabled = true;
                    btn.innerHTML = '<div class="loading mx-auto"></div>';
                    tokens.forEach(t => t.disabled = true);
                } else {
                    btn.disabled = false;
                    btn.innerHTML = 'ğŸ² çœŸå®åŒºå—é“¾è½¬ç›˜';
                    tokens.forEach(t => t.disabled = false);
                }
            }

            updateStats() {
                const { stats } = this.state;
                const els = ['totalGames', 'winCount', 'totalReward', 'winRate'];
                
                document.getElementById(els[0]).textContent = stats.totalGames;
                document.getElementById(els[1]).textContent = stats.winCount;
                document.getElementById(els[2]).textContent = this.formatNumber(stats.totalReward);
                
                const rate = stats.totalGames > 0 ? ((stats.winCount / stats.totalGames) * 100).toFixed(1) : 0;
                document.getElementById(els[3]).textContent = `${rate}%`;
            }

            startSpin() {
                document.getElementById('wheel')?.classList.add('spinning');
            }

            stopSpin() {
                document.getElementById('wheel')?.classList.remove('spinning');
            }

            showResult(result, hash) {
                this.stopSpin();
                this.state.isPlaying = false;
                this.updateUI(false);

                const modal = document.getElementById('resultModal');
                const icon = document.getElementById('resultIcon');
                const title = document.getElementById('resultTitle');
                const msg = document.getElementById('resultMessage');
                const reward = document.getElementById('resultReward');
                const tx = document.getElementById('txHash');

                if (result.isWin) {
                    icon.textContent = 'ğŸ‰';
                    title.textContent = 'ğŸŠ çœŸå®åŒºå—é“¾ä¸­å¥–ï¼';
                    msg.textContent = `ç­‰çº§ ${result.level} - çœŸå®å¥–åŠ±å·²å‘æ”¾åˆ°é’±åŒ…`;
                    reward.textContent = `+${this.formatNumber(result.amount)} ${this.state.selectedToken}`;
                } else {
                    icon.textContent = 'ğŸ¯';
                    title.textContent = 'çœŸå®åŒºå—é“¾æ¸¸æˆ';
                    msg.textContent = 'è¿™æ¬¡æ²¡ä¸­å¥–ï¼Œä½†æ˜¯çœŸå®çš„åŒºå—é“¾äº¤æ˜“ï¼';
                    reward.textContent = 'ç»§ç»­çœŸå®æ¸¸æˆ';
                }

                if (hash) {
                    tx.innerHTML = `<a href="https://alveyscan.com/tx/${hash}" target="_blank" class="text-blue-300">æŸ¥çœ‹çœŸå®äº¤æ˜“: ${hash.slice(0, 16)}...</a>`;
                } else {
                    tx.textContent = '';
                }

                modal.classList.remove('hidden');
                setTimeout(() => this.updateBalances(), 2000);
            }

            // ğŸ”§ ä¿®å¤ï¼šæ™ºèƒ½RPCæµ‹è¯•ï¼Œä½¿ç”¨æ›´é•¿è¶…æ—¶æ—¶é—´
            async testRpcNode(rpcUrl, timeout = 15000) {
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), timeout);
                    
                    const response = await fetch(rpcUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            jsonrpc: '2.0',
                            method: 'eth_blockNumber',
                            params: [],
                            id: 1
                        }),
                        signal: controller.signal
                    });
                    
                    clearTimeout(timeoutId);
                    
                    if (response.ok) {
                        const data = await response.json();
                        if (data.result) {
                            console.log(`âœ… RPCèŠ‚ç‚¹ ${rpcUrl} æµ‹è¯•æˆåŠŸ`);
                            return true;
                        }
                    }
                    return false;
                } catch (error) {
                    console.error(`âŒ RPCèŠ‚ç‚¹ ${rpcUrl} æµ‹è¯•å¤±è´¥:`, error.message);
                    return false;
                }
            }

            async findWorkingRpcNode() {
                this.setNetwork('æ™ºèƒ½æµ‹è¯•RPCèŠ‚ç‚¹...', 'info');
                
                for (let i = 0; i < this.rpcNodes.length; i++) {
                    const rpcUrl = this.rpcNodes[i];
                    this.setNetwork(`æµ‹è¯•èŠ‚ç‚¹ ${i + 1}/${this.rpcNodes.length}...`, 'info');
                    
                    const isWorking = await this.testRpcNode(rpcUrl);
                    if (isWorking) {
                        this.state.currentRpcIndex = i;
                        this.setNetwork(`ğŸŸ¢ è¿æ¥æˆåŠŸ: èŠ‚ç‚¹${i + 1}`, 'success');
                        return rpcUrl;
                    }
                }
                
                // å¦‚æœæ‰€æœ‰èŠ‚ç‚¹éƒ½å¤±è´¥ï¼Œä½¿ç”¨ç¬¬ä¸€ä¸ªä½œä¸ºé»˜è®¤
                console.log('æ‰€æœ‰èŠ‚ç‚¹æµ‹è¯•å®Œæˆï¼Œä½¿ç”¨é»˜è®¤èŠ‚ç‚¹');
                this.state.currentRpcIndex = 0;
                return this.rpcNodes[0];
            }

            // ğŸ”§ ä¿®å¤ï¼šå¢å¼ºçš„ç½‘ç»œè®¾ç½®
            async setupNetwork() {
                try {
                    this.setNetwork('åˆå§‹åŒ–AlveyChainè¿æ¥...', 'info');
                    
                    if (!window.ethereum) {
                        throw new Error('è¯·å®‰è£… MetaMask æ‰èƒ½è¿›è¡ŒçœŸå®åŒºå—é“¾æ¸¸æˆ');
                    }

                    // æ‰¾åˆ°å¯ç”¨çš„RPCèŠ‚ç‚¹
                    const workingRpc = await this.findWorkingRpcNode();

                    const chainId = await window.ethereum.request({ method: 'eth_chainId' });
                    const target = '0xED5'; // AlveyChain 3797
                    
                    if (chainId !== target) {
                        this.setNetwork('åˆ‡æ¢åˆ° AlveyChain ä¸»ç½‘...', 'warning');
                        
                        try {
                            await window.ethereum.request({
                                method: 'wallet_switchEthereumChain',
                                params: [{ chainId: target }]
                            });
                        } catch (switchError) {
                            if (switchError.code === 4902) {
                                await window.ethereum.request({
                                    method: 'wallet_addEthereumChain',
                                    params: [{
                                        chainId: target,
                                        chainName: 'AlveyChain Mainnet',
                                        nativeCurrency: { name: 'ALV', symbol: 'ALV', decimals: 18 },
                                        rpcUrls: [workingRpc],
                                        blockExplorerUrls: ['https://alveyscan.com']
                                    }]
                                });
                            }
                        }
                    }

                    // éªŒè¯è¿æ¥
                    const provider = new ethers.providers.Web3Provider(window.ethereum);
                    const network = await provider.getNetwork();
                    
                    if (network.chainId !== 3797) {
                        throw new Error(`ç½‘ç»œIDé”™è¯¯: ${network.chainId}, åº”è¯¥æ˜¯3797`);
                    }

                    this.state.networkReady = true;
                    this.setNetwork(`ğŸŸ¢ AlveyChainå·²è¿æ¥ (èŠ‚ç‚¹${this.state.currentRpcIndex + 1})`, 'success');
                    return true;

                } catch (error) {
                    console.error('ç½‘ç»œè®¾ç½®å¤±è´¥:', error);
                    this.state.networkReady = false;
                    this.setNetwork(`âŒ ç½‘ç»œé”™è¯¯: ${error.message}`, 'error');
                    return false;
                }
            }

            async connectWallet() {
                try {
                    const networkOk = await this.setupNetwork();
                    if (!networkOk) {
                        this.setStatus('è¯·å…ˆæ­£ç¡®è¿æ¥AlveyChainç½‘ç»œ', 'error');
                        return;
                    }

                    this.setStatus('è¿æ¥åŒºå—é“¾é’±åŒ…...', 'loading');

                    const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                    if (!accounts.length) {
                        this.setStatus('è¯·æˆæƒé’±åŒ…è¿æ¥', 'warning');
                        return;
                    }

                    this.state.wallet = {
                        address: accounts[0],
                        provider: new ethers.providers.Web3Provider(window.ethereum),
                        connected: true
                    };
                    this.state.wallet.signer = this.state.wallet.provider.getSigner();

                    // åˆå§‹åŒ–æ™ºèƒ½åˆçº¦
                    this.setStatus('åˆå§‹åŒ–æ™ºèƒ½åˆçº¦...', 'loading');
                    
                    this.state.contracts.mao = new ethers.Contract(this.addresses.MAO_TOKEN, this.tokenABI, this.state.wallet.signer);
                    this.state.contracts.pi = new ethers.Contract(this.addresses.PI_TOKEN, this.tokenABI, this.state.wallet.signer);
                    this.state.contracts.wheelGame = new ethers.Contract(this.addresses.WHEEL_GAME, this.gameABI, this.state.wallet.signer);

                    // éªŒè¯åˆçº¦è¿æ¥
                    await Promise.all([
                        this.state.contracts.mao.symbol(),
                        this.state.contracts.pi.symbol()
                    ]);

                    this.updateWallet();
                    await this.updateBalances();
                    await this.loadStats();
                    this.setStatus('ğŸš€ æ™ºèƒ½åŒºå—é“¾ç³»ç»Ÿå·²å®Œå…¨è¿æ¥', 'success');

                } catch (error) {
                    console.error('é’±åŒ…è¿æ¥å¤±è´¥:', error);
                    this.setStatus(`è¿æ¥å¤±è´¥: ${error.message}`, 'error');
                }
            }

            updateWallet() {
                const disc = document.getElementById('walletDisconnected');
                const conn = document.getElementById('walletConnected');
                
                if (this.state.wallet.connected) {
                    disc?.classList.add('hidden');
                    conn?.classList.remove('hidden');
                    document.getElementById('walletAddress').textContent = this.formatAddress(this.state.wallet.address);
                } else {
                    disc?.classList.remove('hidden');
                    conn?.classList.add('hidden');
                }
            }

            async updateBalances() {
                if (!this.state.wallet.connected) return;

                try {
                    const [maoBalance, piBalance] = await Promise.all([
                        this.state.contracts.mao.balanceOf(this.state.wallet.address),
                        this.state.contracts.pi.balanceOf(this.state.wallet.address)
                    ]);

                    document.getElementById('maoBalance').textContent = this.formatNumber(ethers.utils.formatEther(maoBalance));
                    document.getElementById('piBalance').textContent = this.formatNumber(ethers.utils.formatEther(piBalance));
                } catch (error) {
                    console.error('æ›´æ–°ä½™é¢å¤±è´¥:', error);
                    this.setStatus('ä½™é¢æŸ¥è¯¢å¤±è´¥ï¼Œç½‘ç»œå¯èƒ½æœ‰å»¶è¿Ÿ', 'warning');
                }
            }

            async loadStats() {
                if (!this.state.contracts.wheelGame) return;

                try {
                    const history = await this.state.contracts.wheelGame.getPlayerHistory(this.state.wallet.address);

                    let totalGames = 0;
                    let winCount = 0;
                    let totalReward = 0;

                    history.forEach(game => {
                        totalGames++;
                        if (game.rewardAmount.gt(0)) {
                            winCount++;
                            totalReward += parseFloat(ethers.utils.formatEther(game.rewardAmount));
                        }
                    });

                    this.state.stats = { totalGames, winCount, totalReward };
                    this.updateStats();

                } catch (error) {
                    console.error('åŠ è½½ç»Ÿè®¡å¤±è´¥:', error);
                }
            }

            // ğŸ”§ ä¿®å¤ï¼šæ™ºèƒ½åˆçº¦è°ƒç”¨é‡è¯•æœºåˆ¶ï¼Œæ›´é•¿çš„è¶…æ—¶æ—¶é—´
            async executeContractCall(contractCall, retries = 3, description = "åˆçº¦è°ƒç”¨") {
                for (let attempt = 1; attempt <= retries; attempt++) {
                    try {
                        this.setStatus(`${description} (å°è¯• ${attempt}/${retries})...`, 'loading');
                        
                        // ä¸ºæ¯ä¸ªè°ƒç”¨è®¾ç½®è¶…æ—¶
                        const result = await Promise.race([
                            contractCall(),
                            new Promise((_, reject) => 
                                setTimeout(() => reject(new Error('æ“ä½œè¶…æ—¶')), 45000) // 45ç§’è¶…æ—¶
                            )
                        ]);
                        
                        return result;
                    } catch (error) {
                        console.error(`${description}å°è¯• ${attempt} å¤±è´¥:`, error);
                        
                        if (attempt < retries) {
                            if (error.message.includes('timeout') || 
                                error.message.includes('network') || 
                                error.message.includes('CONNECTION')) {
                                
                                this.setStatus(`ç½‘ç»œå»¶è¿Ÿï¼Œåˆ‡æ¢åˆ°å¤‡ç”¨èŠ‚ç‚¹...`, 'warning');
                                this.state.currentRpcIndex = (this.state.currentRpcIndex + 1) % this.rpcNodes.length;
                                
                                // ç­‰å¾…æ›´é•¿æ—¶é—´ä»¥é€‚åº”ç½‘ç»œå»¶è¿Ÿ
                                await new Promise(resolve => setTimeout(resolve, 5000 * attempt));
                            } else {
                                await new Promise(resolve => setTimeout(resolve, 3000 * attempt));
                            }
                        } else {
                            throw error;
                        }
                    }
                }
            }

            async startRealBlockchainGame() {
                if (!this.state.wallet.connected || !this.state.networkReady) {
                    this.setStatus('è¯·å…ˆè¿æ¥é’±åŒ…å’Œç½‘ç»œè¿›è¡ŒçœŸå®åŒºå—é“¾æ¸¸æˆ', 'warning');
                    return;
                }

                if (this.state.isPlaying) return;

                try {
                    this.state.isPlaying = true;
                    this.updateUI(true);

                    const { selectedToken } = this.state;
                    const tokenContract = selectedToken === 'MAO' ? this.state.contracts.mao : this.state.contracts.pi;
                    const amount = ethers.utils.parseEther(selectedToken === 'MAO' ? '100' : '1000');
                    
                    // æ£€æŸ¥ä½™é¢
                    this.setStatus('æ£€æŸ¥ä»£å¸ä½™é¢...', 'loading');
                    const balance = await this.executeContractCall(
                        () => tokenContract.balanceOf(this.state.wallet.address),
                        3,
                        "ä½™é¢æŸ¥è¯¢"
                    );
                    
                    if (balance.lt(amount)) {
                        throw new Error(`ä½™é¢ä¸è¶³ï¼éœ€è¦ ${selectedToken === 'MAO' ? '100' : '1000'} ${selectedToken} ä»£å¸`);
                    }

                    // æ£€æŸ¥æˆæƒ
                    this.setStatus('æ£€æŸ¥æ™ºèƒ½åˆçº¦æˆæƒ...', 'loading');
                    const allowance = await this.executeContractCall(
                        () => tokenContract.allowance(this.state.wallet.address, this.addresses.WHEEL_GAME),
                        3,
                        "æˆæƒæŸ¥è¯¢"
                    );
                    
                    if (allowance.lt(amount)) {
                        this.setStatus('æˆæƒæ™ºèƒ½åˆçº¦è®¿é—®ä»£å¸...', 'loading');
                        
                        const approveTx = await this.executeContractCall(async () => {
                            return await tokenContract.approve(this.addresses.WHEEL_GAME, ethers.constants.MaxUint256, {
                                gasLimit: 150000,
                                gasPrice: ethers.utils.parseUnits('30', 'gwei')
                            });
                        }, 3, "ä»£å¸æˆæƒ");
                        
                        this.setStatus('ç­‰å¾…æˆæƒäº¤æ˜“ç¡®è®¤...', 'loading');
                        await approveTx.wait(5);
                        this.setStatus('æˆæƒæˆåŠŸï¼Œå‡†å¤‡æ¸¸æˆ', 'success');
                    }

                    this.setStatus('å¯åŠ¨çœŸå®åŒºå—é“¾è½¬ç›˜...', 'loading');
                    this.startSpin();
                    
                    // ğŸ”— åŒºå—é“¾æ¸¸æˆè°ƒç”¨ï¼Œä½¿ç”¨æ›´é«˜çš„Gasè®¾ç½®
                    const gasOptions = {
                        gasLimit: selectedToken === 'MAO' ? 1500000 : 1800000, // æ›´é«˜çš„Gasé™åˆ¶
                        gasPrice: ethers.utils.parseUnits('35', 'gwei') // æ›´é«˜çš„Gasä»·æ ¼ç¡®ä¿æˆåŠŸ
                    };
                    
                    const gameTx = await this.executeContractCall(async () => {
                        if (selectedToken === 'MAO') {
                            return await this.state.contracts.wheelGame.playMAOGame(gasOptions);
                        } else {
                            return await this.state.contracts.wheelGame.playPIGame(gasOptions);
                        }
                    }, 3, "åŒºå—é“¾æ¸¸æˆ");

                    this.setStatus('çœŸå®åŒºå—é“¾ç¡®è®¤ä¸­...è¯·è€å¿ƒç­‰å¾…', 'loading');
                    const receipt = await gameTx.wait(10); // ç­‰å¾…10ä¸ªç¡®è®¤

                    // è§£æç»“æœ
                    let result = null;
                    
                    // äº‹ä»¶è§£æ
                    try {
                        if (receipt.events && receipt.events.length > 0) {
                            const gameEvent = receipt.events.find(e => e.event === 'GamePlayed');
                            if (gameEvent && gameEvent.args) {
                                const { rewardAmount, rewardLevel } = gameEvent.args;
                                result = {
                                    isWin: rewardAmount.gt(0),
                                    amount: ethers.utils.formatEther(rewardAmount),
                                    level: rewardLevel.toString()
                                };
                            }
                        }
                    } catch (eventError) {
                        console.log('äº‹ä»¶è§£æå¤±è´¥ï¼Œå°è¯•å†å²æŸ¥è¯¢');
                    }
                    
                    // å†å²æŸ¥è¯¢
                    if (!result) {
                        try {
                            this.setStatus('æŸ¥è¯¢æ¸¸æˆè®°å½•...', 'loading');
                            await new Promise(resolve => setTimeout(resolve, 8000)); // ç­‰å¾…8ç§’
                            
                            const newHistory = await this.executeContractCall(
                                () => this.state.contracts.wheelGame.getPlayerHistory(this.state.wallet.address),
                                3,
                                "å†å²æŸ¥è¯¢"
                            );
                            
                            if (newHistory.length > 0) {
                                const lastGame = newHistory[newHistory.length - 1];
                                const timeDiff = Date.now() / 1000 - lastGame.timestamp.toNumber();
                                if (timeDiff < 1200) { // 20åˆ†é’Ÿå†…çš„æ¸¸æˆ
                                    result = {
                                        isWin: lastGame.rewardAmount.gt(0),
                                        amount: ethers.utils.formatEther(lastGame.rewardAmount),
                                        level: lastGame.rewardLevel.toString()
                                    };
                                }
                            }
                        } catch (historyError) {
                            console.error('å†å²æŸ¥è¯¢å¤±è´¥:', historyError);
                        }
                    }
                    
                    // å¦‚æœä»ç„¶æ— æ³•è§£æç»“æœ
                    if (!result) {
                        result = {
                            isWin: false,
                            amount: '0',
                            level: '0'
                        };
                        this.setStatus('æ¸¸æˆå·²å®Œæˆï¼Œä½†è§£æç»“æœæ—¶é‡åˆ°ç½‘ç»œå»¶è¿Ÿã€‚è¯·æŸ¥çœ‹é’±åŒ…ä½™é¢å˜åŒ–ã€‚', 'warning');
                    }

                    // æ˜¾ç¤ºç»“æœ
                    setTimeout(() => {
                        this.showResult(result, gameTx.hash);
                        this.loadStats();
                    }, 2000);

                } catch (error) {
                    console.error('çœŸå®åŒºå—é“¾æ¸¸æˆé”™è¯¯:', error);
                    
                    let errorMsg = error.message;
                    
                    // ğŸ”§ å¢å¼ºé”™è¯¯è¯Šæ–­ - æ›´è¯¦ç»†çš„é”™è¯¯åˆ†æ
                    if (errorMsg.includes('insufficient funds')) {
                        errorMsg = 'ä½™é¢ä¸è¶³ï¼Œè¯·å……å€¼è¶³å¤Ÿçš„ä»£å¸å’ŒALV';
                    } else if (errorMsg.includes('user rejected')) {
                        errorMsg = 'ç”¨æˆ·å–æ¶ˆäº†äº¤æ˜“';
                    } else if (errorMsg.includes('gas')) {
                        errorMsg = 'Gasè´¹ç”¨ä¸è¶³ï¼Œè¯·å¢åŠ Gasè´¹ç”¨';
                    } else if (errorMsg.includes('timeout') || errorMsg.includes('è¶…æ—¶')) {
                        errorMsg = 'ç½‘ç»œå“åº”è¾ƒæ…¢ï¼Œè¯·ç¨åé‡è¯•ã€‚å¦‚æœäº¤æ˜“å·²æäº¤ï¼Œè¯·æ£€æŸ¥é’±åŒ…å†å²è®°å½•ã€‚';
                    } else if (errorMsg.includes('network') || errorMsg.includes('RPC')) {
                        errorMsg = 'ç½‘ç»œè¿æ¥é—®é¢˜ï¼Œå·²è‡ªåŠ¨å°è¯•å¤‡ç”¨èŠ‚ç‚¹';
                    } else if (errorMsg.includes('CALL_EXCEPTION')) {
                        errorMsg = 'æ™ºèƒ½åˆçº¦è°ƒç”¨å¤±è´¥ï¼Œå¯èƒ½æ˜¯ç½‘ç»œæ‹¥å µï¼Œè¯·ç¨åé‡è¯•';
                    } else if (errorMsg.includes('execution reverted')) {
                        // ğŸ” æ›´è¯¦ç»†çš„åˆçº¦é”™è¯¯åˆ†æ
                        if (errorMsg.includes('Insufficient user balance')) {
                            errorMsg = 'MAOä½™é¢ä¸è¶³ï¼Œéœ€è¦è‡³å°‘100ä¸ªMAOä»£å¸è¿›è¡Œæ¸¸æˆ';
                        } else if (errorMsg.includes('Insufficient user allowance')) {
                            errorMsg = 'MAOæˆæƒä¸è¶³ï¼Œè¯·å…ˆæˆæƒæ¸¸æˆåˆçº¦ä½¿ç”¨ä½ çš„MAOä»£å¸';
                        } else if (errorMsg.includes('Insufficient prize pool allowance')) {
                            errorMsg = 'å¥–é‡‘æ± æˆæƒé—®é¢˜ï¼Œè¯·è”ç³»ç®¡ç†å‘˜ä¿®å¤';
                        } else if (errorMsg.includes('MAO transfer failed')) {
                            errorMsg = 'MAOè½¬è´¦å¤±è´¥ï¼Œå¯èƒ½æ˜¯ä½™é¢æˆ–æˆæƒä¸è¶³';
                        } else {
                            errorMsg = 'æ™ºèƒ½åˆçº¦æ‰§è¡Œå¤±è´¥ï¼Œè¯·æ£€æŸ¥ä½™é¢å’ŒæˆæƒçŠ¶æ€';
                        }
                    } else {
                        // ğŸ” ä¸ºæœªçŸ¥é”™è¯¯æä¾›æ›´å¤šä¿¡æ¯
                        errorMsg = `æ¸¸æˆè°ƒç”¨å¤±è´¥: ${errorMsg.substring(0, 100)}...è¯·æ£€æŸ¥MAOä½™é¢å’Œæˆæƒ`;
                    }

                    this.setStatus(`âŒ ${errorMsg}`, 'error');
                    
                    // ğŸ”§ æ·»åŠ è¯Šæ–­å»ºè®®
                    setTimeout(() => {
                        if (errorMsg.includes('ä½™é¢') || errorMsg.includes('æˆæƒ')) {
                            this.setStatus('ğŸ’¡ å»ºè®®ï¼šæ£€æŸ¥MetaMaskä¸­çš„MAOä½™é¢(â‰¥100ä¸ª)å’ŒALVä½™é¢(â‰¥0.01ä¸ª)', 'warning');
                        }
                    }, 3000);
                    
                    this.stopSpin();
                    this.state.isPlaying = false;
                    this.updateUI(false);
                }
            }

            init() {
                document.addEventListener('DOMContentLoaded', () => {
                    this.setupEvents();
                    this.updateTokens();
                    this.updateStats();
                    this.setupNetwork();
                });

                if (window.ethereum) {
                    window.ethereum.on('accountsChanged', (accounts) => {
                        if (accounts.length === 0) {
                            this.state.wallet.connected = false;
                            this.state.networkReady = false;
                            this.updateWallet();
                            this.setStatus('é’±åŒ…å·²æ–­å¼€', 'warning');
                        } else {
                            this.connectWallet();
                        }
                    });

                    window.ethereum.on('chainChanged', () => {
                        this.setStatus('ç½‘ç»œå·²åˆ‡æ¢ï¼Œé‡æ–°åˆå§‹åŒ–...', 'info');
                        this.state.networkReady = false;
                        setTimeout(() => window.location.reload(), 1000);
                    });
                }
            }

            setupEvents() {
                document.getElementById('connectBtn')?.addEventListener('click', () => this.connectWallet());

                document.getElementById('selectMao')?.addEventListener('click', () => {
                    this.state.selectedToken = 'MAO';
                    this.updateTokens();
                    this.setStatus('MAO ä»£å¸æ¸¸æˆæ¨¡å¼', 'info');
                });
                
                document.getElementById('selectPi')?.addEventListener('click', () => {
                    this.state.selectedToken = 'PI';
                    this.updateTokens();
                    this.setStatus('PI ä»£å¸æ¸¸æˆæ¨¡å¼', 'info');
                });

                document.getElementById('spinBtn')?.addEventListener('click', () => this.startRealBlockchainGame());

                document.getElementById('closeModal')?.addEventListener('click', () => {
                    document.getElementById('resultModal')?.classList.add('hidden');
                });
            }
        }

        // ğŸš€ å¯åŠ¨æœ€ç»ˆä¿®å¤ç‰ˆæœ¬ v8.7
        const fixedFinalGame = new FixedFinalBlockchainGame();
        fixedFinalGame.init();
    </script>
</body>
</html>
