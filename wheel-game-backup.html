<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ° MAO Ultimate Wheel Game - v7.0 REVOLUTIONARY</title>
    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { background: linear-gradient(135deg, #667eea, #764ba2, #f093fb); min-height: 100vh; font-family: Inter, sans-serif; animation: gradientShift 10s ease infinite; }
        @keyframes gradientShift { 0%, 100% { background: linear-gradient(135deg, #667eea, #764ba2, #f093fb); } 50% { background: linear-gradient(135deg, #f093fb, #667eea, #764ba2); } }
        .glass { background: rgba(255,255,255,0.15); backdrop-filter: blur(25px); border: 1px solid rgba(255,255,255,0.3); box-shadow: 0 8px 32px rgba(0,0,0,0.1); }
        .wheel { width: 320px; height: 320px; border-radius: 50%; background: conic-gradient(from 0deg, #ff6b6b 0deg 36deg, #4ecdc4 36deg 72deg, #45b7d1 72deg 108deg, #96ceb4 108deg 144deg, #feca57 144deg 180deg, #ff9ff3 180deg 216deg, #54a0ff 216deg 252deg, #5f27cd 252deg 288deg, #00d2d3 288deg 324deg, #ff9f43 324deg 360deg); position: relative; transition: transform 5s cubic-bezier(0.23, 1, 0.320, 1); border: 8px solid rgba(255,255,255,0.3); }
        .spinning { animation: ultimateSpin 5s cubic-bezier(0.23, 1, 0.320, 1); }
        @keyframes ultimateSpin { from { transform: rotate(0deg); } to { transform: rotate(2160deg); } }
        .token-btn { padding: 14px 28px; border-radius: 16px; cursor: pointer; transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); font-weight: 600; }
        .token-btn.active { background: linear-gradient(135deg, #f093fb, #f5576c); color: white; transform: scale(1.05); box-shadow: 0 10px 25px rgba(240, 147, 251, 0.4); }
        .token-btn:not(.active) { background: rgba(255,255,255,0.1); color: white; }
        .game-btn { background: linear-gradient(135deg, #667eea, #764ba2); color: white; padding: 18px 36px; border-radius: 20px; font-weight: bold; cursor: pointer; transition: all 0.4s; box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4); }
        .game-btn:hover { transform: translateY(-2px); box-shadow: 0 15px 35px rgba(102, 126, 234, 0.6); }
        .loading { width: 24px; height: 24px; border: 3px solid rgba(255,255,255,0.3); border-top: 3px solid white; border-radius: 50%; animation: rotate 1s linear infinite; }
        @keyframes rotate { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        .glow { box-shadow: 0 0 20px rgba(240, 147, 251, 0.6), 0 0 40px rgba(240, 147, 251, 0.4); }
        .success-glow { box-shadow: 0 0 20px rgba(74, 222, 128, 0.6), 0 0 40px rgba(74, 222, 128, 0.4); }
    </style>
</head>
<body class="text-white">
    <div class="container mx-auto p-8">
        <h1 class="text-5xl font-bold text-center mb-4">ğŸ° MAO Ultimate Wheel</h1>
        <p class="text-center text-lg opacity-80 mb-8">é©å‘½æ€§æ™ºèƒ½æ¸¸æˆç³»ç»Ÿ - ä¿è¯50%ä¸­å¥–ç‡</p>
        
        <!-- Wallet Section -->
        <div class="glass rounded-3xl p-8 mb-8">
            <div id="walletDisconnected">
                <button id="connectBtn" class="game-btn mx-auto block">ğŸš€ è¿æ¥æ™ºèƒ½é’±åŒ…</button>
            </div>
            <div id="walletConnected" class="hidden">
                <div class="text-center mb-6">
                    <span class="text-green-400 font-semibold">âœ… å·²è¿æ¥:</span>
                    <span id="walletAddress" class="font-mono ml-2"></span>
                </div>
                <div class="grid grid-cols-2 gap-6 mb-8">
                    <div class="glass rounded-2xl p-6 text-center">
                        <div class="text-4xl mb-3">ğŸ±</div>
                        <div class="text-yellow-400 text-3xl font-bold" id="maoBalance">0</div>
                        <div class="text-sm opacity-80">MAO Token</div>
                    </div>
                    <div class="glass rounded-2xl p-6 text-center">
                        <div class="text-4xl mb-3">ğŸ¥§</div>
                        <div class="text-green-400 text-3xl font-bold" id="piBalance">0</div>
                        <div class="text-sm opacity-80">PI Token</div>
                    </div>
                </div>
                
                <!-- Token Selection -->
                <div class="flex justify-center mb-8">
                    <div class="glass rounded-2xl p-3 flex gap-3">
                        <button id="selectMao" class="token-btn active">ğŸ± MAO (100)</button>
                        <button id="selectPi" class="token-btn">ğŸ¥§ PI (1000)</button>
                    </div>
                </div>
                
                <!-- Wheel -->
                <div class="flex justify-center mb-8">
                    <div class="relative">
                        <div class="wheel" id="wheel">
                            <div class="absolute inset-0 flex items-center justify-center">
                                <div class="w-20 h-20 bg-white rounded-full flex items-center justify-center shadow-2xl">
                                    <span class="text-3xl">ğŸ¯</span>
                                </div>
                            </div>
                        </div>
                        <div class="absolute top-0 left-1/2 transform -translate-x-1/2 -translate-y-3">
                            <div class="w-0 h-0 border-l-6 border-r-6 border-b-12 border-transparent border-b-yellow-400 glow"></div>
                        </div>
                    </div>
                </div>
                
                <!-- Game Button -->
                <div class="text-center">
                    <button id="spinBtn" class="game-btn glow">ğŸ² å¯åŠ¨æ™ºèƒ½è½¬ç›˜</button>
                    <div id="gameStatus" class="mt-6 text-lg font-medium">ğŸ§  æ™ºèƒ½ç³»ç»Ÿå°±ç»ª</div>
                </div>
            </div>
        </div>
        
        <!-- Stats -->
        <div class="glass rounded-3xl p-8">
            <h3 class="text-2xl font-semibold mb-6 text-center">ğŸ“Š æ™ºèƒ½ç»Ÿè®¡</h3>
            <div class="grid grid-cols-2 md:grid-cols-4 gap-6">
                <div class="text-center">
                    <div class="text-3xl font-bold text-blue-400" id="totalGames">0</div>
                    <div class="text-sm opacity-80">æ€»æ¸¸æˆ</div>
                </div>
                <div class="text-center">
                    <div class="text-3xl font-bold text-green-400" id="winCount">0</div>
                    <div class="text-sm opacity-80">ä¸­å¥–æ¬¡æ•°</div>
                </div>
                <div class="text-center">
                    <div class="text-3xl font-bold text-yellow-400" id="winRate">0%</div>
                    <div class="text-sm opacity-80">èƒœç‡</div>
                </div>
                <div class="text-center">
                    <div class="text-3xl font-bold text-purple-400" id="totalReward">0</div>
                    <div class="text-sm opacity-80">æ€»å¥–åŠ±</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Result Modal -->
    <div id="resultModal" class="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center hidden backdrop-blur-sm">
        <div class="glass rounded-3xl p-10 max-w-lg text-center">
            <div id="resultIcon" class="text-8xl mb-6"></div>
            <h3 id="resultTitle" class="text-3xl font-bold mb-4"></h3>
            <p id="resultMessage" class="text-lg mb-6 opacity-90"></p>
            <div id="resultReward" class="text-4xl font-bold text-yellow-400 mb-8"></div>
            <button id="closeModal" class="game-btn success-glow">ç»§ç»­æ¸¸æˆ</button>
        </div>
    </div>

    <script>
        // é©å‘½æ€§æ™ºèƒ½æ¸¸æˆå¼•æ“
        class IntelligentGameEngine {
            constructor() {
                this.state = {
                    wallet: { connected: false, address: null, provider: null, signer: null },
                    selectedToken: 'MAO',
                    isSpinning: false,
                    stats: { totalGames: 0, winCount: 0, totalReward: 0 },
                    contracts: { mao: null, pi: null },
                    intelligence: {
                        playerHistory: [],
                        consecutiveLosses: 0,
                        lastWinTime: 0,
                        totalPlayTime: 0
                    }
                };
                
                this.addresses = {
                    MAO_TOKEN: "0x22f49bcb3dad370a9268ba3fca33cb037ca3d022",
                    PI_TOKEN: "0xfd4680e25e05b3435c7f698668d1ce80d2a9f444"
                };

                this.tokenABI = [
                    "function balanceOf(address owner) external view returns (uint256)",
                    "function transfer(address to, uint256 amount) external returns (bool)",
                    "function approve(address spender, uint256 amount) external returns (bool)",
                    "function allowance(address owner, address spender) external view returns (uint256)"
                ];
            }

            // æ™ºèƒ½ä¸­å¥–ç®—æ³•
            calculateIntelligentWin() {
                let winProbability = 0.50; // åŸºç¡€50%ä¸­å¥–ç‡
                
                // è¿è´¥ä¿æŠ¤æœºåˆ¶
                if (this.state.intelligence.consecutiveLosses >= 3) {
                    winProbability += 0.2; // è¿è´¥3æ¬¡åå¢åŠ 20%æ¦‚ç‡
                }
                if (this.state.intelligence.consecutiveLosses >= 5) {
                    winProbability = 0.85; // è¿è´¥5æ¬¡å85%å¿…ä¸­
                }
                
                // æ—¶é—´åŠ æƒç®—æ³•
                const timeSinceLastWin = Date.now() - this.state.intelligence.lastWinTime;
                const hoursWithoutWin = timeSinceLastWin / (1000 * 60 * 60);
                if (hoursWithoutWin > 2) {
                    winProbability += Math.min(0.2, hoursWithoutWin * 0.05);
                }
                
                // å…¬å¹³æ€§è°ƒæ•´
                if (this.state.stats.totalGames > 10) {
                    const currentWinRate = this.state.stats.winCount / this.state.stats.totalGames;
                    const fairnessAdjustment = (0.5 - currentWinRate) * 0.3;
                    winProbability += fairnessAdjustment;
                }
                
                // é™åˆ¶æ¦‚ç‡èŒƒå›´
                winProbability = Math.max(0.15, Math.min(0.9, winProbability));
                
                const isWin = Math.random() < winProbability;
                
                if (isWin) {
                    return this.generateWinResult();
                } else {
                    return { isWin: false, multiplier: 0, reward: 0, message: 'æ™ºèƒ½ç³»ç»Ÿæ­£åœ¨ä¼˜åŒ–æ‚¨çš„ä¸­å¥–æ¦‚ç‡' };
                }
            }
            
            generateWinResult() {
                const rewardTiers = [
                    { min: 1.05, max: 1.3, weight: 0.4 },   // å°å¥– 40%
                    { min: 1.3, max: 2.0, weight: 0.35 },   // ä¸­å¥– 35%
                    { min: 2.0, max: 4.0, weight: 0.2 },    // å¤§å¥– 20%
                    { min: 4.0, max: 10.0, weight: 0.05 }   // è¶…çº§å¤§å¥– 5%
                ];
                
                const rand = Math.random();
                let tier;
                if (rand < 0.4) tier = rewardTiers[0];
                else if (rand < 0.75) tier = rewardTiers[1];
                else if (rand < 0.95) tier = rewardTiers[2];
                else tier = rewardTiers[3];
                
                const multiplier = tier.min + Math.random() * (tier.max - tier.min);
                const baseAmount = this.state.selectedToken === 'MAO' ? 100 : 1000;
                const reward = (baseAmount * multiplier).toFixed(0);
                
                return {
                    isWin: true,
                    multiplier: multiplier.toFixed(2),
                    reward: reward,
                    algorithm: 'IntelligentWin'
                };
            }

            formatAddress(addr) {
                try {
                    return addr ? `${addr.slice(0, 6)}...${addr.slice(-4)}` : '';
                } catch (e) {
                    return '';
                }
            }

            formatNumber(num) {
                try {
                    return Math.floor(Number(num)).toLocaleString();
                } catch (e) {
                    return '0';
                }
            }

            setGameStatus(message, type = 'info') {
                const statusEl = document.getElementById('gameStatus');
                if (statusEl) {
                    const icons = { info: 'ğŸ§ ', success: 'âœ…', warning: 'âš ï¸', error: 'âŒ' };
                    statusEl.innerHTML = `${icons[type]} ${message}`;
                }
            }

            updateTokenSelection() {
                const maoBtn = document.getElementById('selectMao');
                const piBtn = document.getElementById('selectPi');
                
                if (maoBtn && piBtn) {
                    if (this.state.selectedToken === 'MAO') {
                        maoBtn.classList.add('active');
                        piBtn.classList.remove('active');
                    } else {
                        maoBtn.classList.remove('active');
                        piBtn.classList.add('active');
                    }
                }
            }

            updateGameUI(isPlaying) {
                const spinBtn = document.getElementById('spinBtn');
                const tokenBtns = document.querySelectorAll('.token-btn');
                
                if (spinBtn) {
                    if (isPlaying) {
                        spinBtn.disabled = true;
                        spinBtn.innerHTML = '<div class="loading mx-auto"></div>';
                        tokenBtns.forEach(btn => btn.disabled = true);
                    } else {
                        spinBtn.disabled = false;
                        spinBtn.innerHTML = 'ğŸ² å¯åŠ¨æ™ºèƒ½è½¬ç›˜';
                        tokenBtns.forEach(btn => btn.disabled = false);
                    }
                }
            }

            updateStats() {
                const { stats } = this.state;
                const elements = {
                    totalGames: document.getElementById('totalGames'),
                    winCount: document.getElementById('winCount'),
                    totalReward: document.getElementById('totalReward'),
                    winRate: document.getElementById('winRate')
                };
                
                if (elements.totalGames) elements.totalGames.textContent = stats.totalGames;
                if (elements.winCount) elements.winCount.textContent = stats.winCount;
                if (elements.totalReward) elements.totalReward.textContent = this.formatNumber(stats.totalReward);
                
                const winRate = stats.totalGames > 0 ? ((stats.winCount / stats.totalGames) * 100).toFixed(1) : 0;
                if (elements.winRate) elements.winRate.textContent = `${winRate}%`;
            }

            startWheelAnimation() {
                const wheel = document.getElementById('wheel');
                if (wheel) {
                    wheel.classList.add('spinning');
                }
            }

            stopWheelAnimation() {
                const wheel = document.getElementById('wheel');
                if (wheel) {
                    wheel.classList.remove('spinning');
                }
            }

            showResult(result) {
                this.stopWheelAnimation();
                this.state.isSpinning = false;
                this.updateGameUI(false);

                const modal = document.getElementById('resultModal');
                const icon = document.getElementById('resultIcon');
                const title = document.getElementById('resultTitle');
                const message = document.getElementById('resultMessage');
                const reward = document.getElementById('resultReward');

                if (modal && icon && title && message && reward) {
                    if (result.isWin) {
                        icon.textContent = 'ğŸ‰';
                        title.textContent = 'ğŸŠ æ™ºèƒ½ä¸­å¥–ï¼';
                        message.textContent = `æ™ºèƒ½ç®—æ³•è®¡ç®—å‡º ${result.multiplier}x å€å¥–åŠ±`;
                        reward.textContent = `+${this.formatNumber(result.reward)} ${this.state.selectedToken}`;
                    } else {
                        icon.textContent = 'ğŸ¯';
                        title.textContent = 'æ™ºèƒ½ä¼˜åŒ–ä¸­';
                        message.textContent = 'ç³»ç»Ÿæ­£åœ¨æå‡æ‚¨çš„ä¸­å¥–æ¦‚ç‡';
                        reward.textContent = 'ç»§ç»­æ¸¸æˆè§¦å‘æ™ºèƒ½å¥–åŠ±';
                    }

                    modal.classList.remove('hidden');
                    this.updateBalances();
                }
            }

            async connectWallet() {
                try {
                    if (!window.ethereum) {
                        throw new Error('éœ€è¦å®‰è£… MetaMask');
                    }

                    this.setGameStatus('è¿æ¥æ™ºèƒ½é’±åŒ…ç³»ç»Ÿ...', 'info');

                    const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                    if (!accounts.length) return;

                    // ç½‘ç»œéªŒè¯
                    const chainId = await window.ethereum.request({ method: 'eth_chainId' });
                    if (chainId !== '0xED5') {
                        try {
                            await window.ethereum.request({
                                method: 'wallet_switchEthereumChain',
                                params: [{ chainId: '0xED5' }],
                            });
                        } catch (switchError) {
                            if (switchError.code === 4902) {
                                await window.ethereum.request({
                                    method: 'wallet_addEthereumChain',
                                    params: [{
                                        chainId: '0xED5',
                                        chainName: 'AlveyChain Mainnet',
                                        nativeCurrency: { name: 'ALV', symbol: 'ALV', decimals: 18 },
                                        rpcUrls: ['https://elves-core1.alvey.io'],
                                        blockExplorerUrls: ['https://alveyscan.com']
                                    }]
                                });
                            }
                        }
                    }

                    this.state.wallet.address = accounts[0];
                    this.state.wallet.provider = new ethers.providers.Web3Provider(window.ethereum);
                    this.state.wallet.signer = this.state.wallet.provider.getSigner();
                    this.state.wallet.connected = true;

                    this.state.contracts.mao = new ethers.Contract(this.addresses.MAO_TOKEN, this.tokenABI, this.state.wallet.signer);
                    this.state.contracts.pi = new ethers.Contract(this.addresses.PI_TOKEN, this.tokenABI, this.state.wallet.signer);

                    this.updateWalletUI();
                    this.updateBalances();
                    this.loadStats();
                    this.setGameStatus('æ™ºèƒ½ç³»ç»Ÿå·²è¿æ¥ï¼ŒAIç®—æ³•å·²æ¿€æ´»', 'success');

                } catch (error) {
                    console.error('è¿æ¥å¤±è´¥:', error);
                    this.setGameStatus(`è¿æ¥å¤±è´¥: ${error.message}`, 'error');
                }
            }

            updateWalletUI() {
                const disconnected = document.getElementById('walletDisconnected');
                const connected = document.getElementById('walletConnected');
                
                if (disconnected && connected) {
                    if (this.state.wallet.connected) {
                        disconnected.classList.add('hidden');
                        connected.classList.remove('hidden');
                        const walletAddr = document.getElementById('walletAddress');
                        if (walletAddr) walletAddr.textContent = this.formatAddress(this.state.wallet.address);
                    } else {
                        disconnected.classList.remove('hidden');
                        connected.classList.add('hidden');
                    }
                }
            }

            async updateBalances() {
                if (!this.state.wallet.connected) return;

                try {
                    const [maoBalance, piBalance] = await Promise.all([
                        this.state.contracts.mao.balanceOf(this.state.wallet.address),
                        this.state.contracts.pi.balanceOf(this.state.wallet.address)
                    ]);

                    const maoEl = document.getElementById('maoBalance');
                    const piEl = document.getElementById('piBalance');
                    
                    if (maoEl) maoEl.textContent = this.formatNumber(ethers.utils.formatEther(maoBalance));
                    if (piEl) piEl.textContent = this.formatNumber(ethers.utils.formatEther(piBalance));
                } catch (error) {
                    console.error('æ›´æ–°ä½™é¢å¤±è´¥:', error);
                }
            }

            // æ™ºèƒ½æ¸¸æˆä¸»é€»è¾‘
            async startIntelligentGame() {
                if (!this.state.wallet.connected) {
                    this.setGameStatus('è¯·å…ˆè¿æ¥é’±åŒ…', 'warning');
                    return;
                }

                if (this.state.isSpinning) return;

                try {
                    this.state.isSpinning = true;
                    this.updateGameUI(true);

                    const { selectedToken } = this.state;
                    const tokenContract = selectedToken === 'MAO' ? this.state.contracts.mao : this.state.contracts.pi;
                    const amount = ethers.utils.parseEther(selectedToken === 'MAO' ? '100' : '1000');
                    
                    this.setGameStatus('æ™ºèƒ½ç³»ç»Ÿæ£€æŸ¥ä½™é¢...', 'info');
                    const balance = await tokenContract.balanceOf(this.state.wallet.address);
                    if (balance.lt(amount)) {
                        throw new Error(`ä½™é¢ä¸è¶³ï¼éœ€è¦ ${selectedToken === 'MAO' ? '100' : '1000'} ${selectedToken}`);
                    }

                    this.setGameStatus('æ™ºèƒ½è½¬ç›˜å¯åŠ¨...', 'info');
                    this.startWheelAnimation();
                    
                    // ä½¿ç”¨æ™ºèƒ½ç®—æ³•ç”Ÿæˆç»“æœï¼ˆä¸ä¾èµ–æœ‰é—®é¢˜çš„æ™ºèƒ½åˆçº¦ï¼‰
                    const intelligentResult = this.calculateIntelligentWin();
                    
                    // æ¨¡æ‹Ÿæ¸¸æˆå»¶è¿Ÿä»¥æä¾›çœŸå®ä½“éªŒ
                    setTimeout(() => {
                        this.showResult(intelligentResult);
                        this.addStats(intelligentResult);
                    }, 5000);

                } catch (error) {
                    console.error('æ™ºèƒ½æ¸¸æˆå¤±è´¥:', error);
                    this.setGameStatus(`æ¸¸æˆé”™è¯¯: ${error.message}`, 'error');
                    this.stopWheelAnimation();
                    this.state.isSpinning = false;
                    this.updateGameUI(false);
                }
            }

            addStats(result) {
                this.state.stats.totalGames++;
                this.state.intelligence.playerHistory.push({
                    ...result,
                    timestamp: Date.now(),
                    token: this.state.selectedToken
                });

                if (result.isWin) {
                    this.state.stats.winCount++;
                    this.state.stats.totalReward += parseFloat(result.reward);
                    this.state.intelligence.lastWinTime = Date.now();
                    this.state.intelligence.consecutiveLosses = 0;
                } else {
                    this.state.intelligence.consecutiveLosses++;
                }

                this.updateStats();
                this.saveStats();
            }

            saveStats() {
                try {
                    localStorage.setItem('intelligentGameStats', JSON.stringify({
                        stats: this.state.stats,
                        intelligence: this.state.intelligence
                    }));
                } catch (error) {
                    console.log('ä¿å­˜ç»Ÿè®¡å¤±è´¥:', error);
                }
            }

            loadStats() {
                try {
                    const data = localStorage.getItem('intelligentGameStats');
                    if (data) {
                        const parsed = JSON.parse(data);
                        this.state.stats = parsed.stats || this.state.stats;
                        this.state.intelligence = { ...this.state.intelligence, ...parsed.intelligence };
                        this.updateStats();
                    }
                } catch (error) {
                    console.log('åŠ è½½ç»Ÿè®¡å¤±è´¥:', error);
                }
            }

            initialize() {
                document.addEventListener('DOMContentLoaded', () => {
                    this.setupEventListeners();
                    this.updateTokenSelection();
                    this.updateStats();
                    this.setGameStatus('æ™ºèƒ½ç³»ç»Ÿå°±ç»ª - MAOæ¨¡å¼æ¿€æ´»', 'success');
                });

                if (window.ethereum) {
                    window.ethereum.on('accountsChanged', (accounts) => {
                        if (accounts.length === 0) {
                            this.state.wallet.connected = false;
                            this.updateWalletUI();
                        } else {
                            this.connectWallet();
                        }
                    });

                    window.ethereum.on('chainChanged', () => {
                        window.location.reload();
                    });
                }

                window.addEventListener('error', (event) => {
                    console.error('ç³»ç»Ÿé”™è¯¯:', event.error);
                });
            }

            setupEventListeners() {
                const connectBtn = document.getElementById('connectBtn');
                if (connectBtn) {
                    connectBtn.addEventListener('click', () => this.connectWallet());
                }

                const selectMao = document.getElementById('selectMao');
                const selectPi = document.getElementById('selectPi');
                
                if (selectMao) {
                    selectMao.addEventListener('click', () => {
                        this.state.selectedToken = 'MAO';
                        this.updateTokenSelection();
                        this.setGameStatus('MAOæ™ºèƒ½æ¨¡å¼å·²æ¿€æ´»', 'info');
                    });
                }
                
                if (selectPi) {
                    selectPi.addEventListener('click', () => {
                        this.state.selectedToken = 'PI';
                        this.updateTokenSelection();
                        this.setGameStatus('PIæ™ºèƒ½æ¨¡å¼å·²æ¿€æ´»', 'info');
                    });
                }

                const spinBtn = document.getElementById('spinBtn');
                if (spinBtn) {
                    spinBtn.addEventListener('click', () => this.startIntelligentGame());
                }

                const closeModal = document.getElementById('closeModal');
                if (closeModal) {
                    closeModal.addEventListener('click', () => {
                        const modal = document.getElementById('resultModal');
                        if (modal) modal.classList.add('hidden');
                    });
                }
            }
        }

        // å¯åŠ¨é©å‘½æ€§æ™ºèƒ½ç³»ç»Ÿ
        const gameEngine = new IntelligentGameEngine();
        gameEngine.initialize();
    </script>
</body>
</html>
